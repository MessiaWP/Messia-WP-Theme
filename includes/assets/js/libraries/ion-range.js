/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/less/_components/_range.less":
/*!******************************************!*\
  !*** ./src/less/_components/_range.less ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/ion-rangeslider/js/ion.rangeSlider.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/ion-rangeslider/js/ion.rangeSlider.js ***!
  \***********************************************************************************************/
/***/ (function(module) {

module.exports = "// Ion.RangeSlider\n// version 2.3.1 Build: 382\n// © Denis Ineshin, 2019\n// https://github.com/IonDen\n//\n// Project page:    http://ionden.com/a/plugins/ion.rangeSlider/en.html\n// GitHub page:     https://github.com/IonDen/ion.rangeSlider\n//\n// Released under MIT licence:\n// http://ionden.com/a/plugins/licence-en.html\n// =====================================================================================================================\n\n;(function(factory) {\n    if ((typeof jQuery === 'undefined' || !jQuery) && typeof define === \"function\" && define.amd) {\n        define([\"jquery\"], function (jQuery) {\n            return factory(jQuery, document, window, navigator);\n        });\n    } else if ((typeof jQuery === 'undefined' || !jQuery) && typeof exports === \"object\") {\n        factory(require(\"jquery\"), document, window, navigator);\n    } else {\n        factory(jQuery, document, window, navigator);\n    }\n} (function ($, document, window, navigator, undefined) {\n    \"use strict\";\n\n    // =================================================================================================================\n    // Service\n\n    var plugin_count = 0;\n\n    // IE8 fix\n    var is_old_ie = (function () {\n        var n = navigator.userAgent,\n            r = /msie\\s\\d+/i,\n            v;\n        if (n.search(r) > 0) {\n            v = r.exec(n).toString();\n            v = v.split(\" \")[1];\n            if (v < 9) {\n                $(\"html\").addClass(\"lt-ie9\");\n                return true;\n            }\n        }\n        return false;\n    } ());\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function bind(that) {\n\n            var target = this;\n            var slice = [].slice;\n\n            if (typeof target != \"function\") {\n                throw new TypeError();\n            }\n\n            var args = slice.call(arguments, 1),\n                bound = function () {\n\n                    if (this instanceof bound) {\n\n                        var F = function(){};\n                        F.prototype = target.prototype;\n                        var self = new F();\n\n                        var result = target.apply(\n                            self,\n                            args.concat(slice.call(arguments))\n                        );\n                        if (Object(result) === result) {\n                            return result;\n                        }\n                        return self;\n\n                    } else {\n\n                        return target.apply(\n                            that,\n                            args.concat(slice.call(arguments))\n                        );\n\n                    }\n\n                };\n\n            return bound;\n        };\n    }\n    if (!Array.prototype.indexOf) {\n        Array.prototype.indexOf = function(searchElement, fromIndex) {\n            var k;\n            if (this == null) {\n                throw new TypeError('\"this\" is null or not defined');\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if (len === 0) {\n                return -1;\n            }\n            var n = +fromIndex || 0;\n            if (Math.abs(n) === Infinity) {\n                n = 0;\n            }\n            if (n >= len) {\n                return -1;\n            }\n            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n            while (k < len) {\n                if (k in O && O[k] === searchElement) {\n                    return k;\n                }\n                k++;\n            }\n            return -1;\n        };\n    }\n\n\n\n    // =================================================================================================================\n    // Template\n\n    var base_html =\n        '<span class=\"irs\">' +\n        '<span class=\"irs-line\" tabindex=\"0\"></span>' +\n        '<span class=\"irs-min\">0</span><span class=\"irs-max\">1</span>' +\n        '<span class=\"irs-from\">0</span><span class=\"irs-to\">0</span><span class=\"irs-single\">0</span>' +\n        '</span>' +\n        '<span class=\"irs-grid\"></span>';\n\n    var single_html =\n        '<span class=\"irs-bar irs-bar--single\"></span>' +\n        '<span class=\"irs-shadow shadow-single\"></span>' +\n        '<span class=\"irs-handle single\"><i></i><i></i><i></i></span>';\n\n    var double_html =\n        '<span class=\"irs-bar\"></span>' +\n        '<span class=\"irs-shadow shadow-from\"></span>' +\n        '<span class=\"irs-shadow shadow-to\"></span>' +\n        '<span class=\"irs-handle from\"><i></i><i></i><i></i></span>' +\n        '<span class=\"irs-handle to\"><i></i><i></i><i></i></span>';\n\n    var disable_html =\n        '<span class=\"irs-disable-mask\"></span>';\n\n\n\n    // =================================================================================================================\n    // Core\n\n    /**\n     * Main plugin constructor\n     *\n     * @param input {Object} link to base input element\n     * @param options {Object} slider config\n     * @param plugin_count {Number}\n     * @constructor\n     */\n    var IonRangeSlider = function (input, options, plugin_count) {\n        this.VERSION = \"2.3.1\";\n        this.input = input;\n        this.plugin_count = plugin_count;\n        this.current_plugin = 0;\n        this.calc_count = 0;\n        this.update_tm = 0;\n        this.old_from = 0;\n        this.old_to = 0;\n        this.old_min_interval = null;\n        this.raf_id = null;\n        this.dragging = false;\n        this.force_redraw = false;\n        this.no_diapason = false;\n        this.has_tab_index = true;\n        this.is_key = false;\n        this.is_update = false;\n        this.is_start = true;\n        this.is_finish = false;\n        this.is_active = false;\n        this.is_resize = false;\n        this.is_click = false;\n\n        options = options || {};\n\n        // cache for links to all DOM elements\n        this.$cache = {\n            win: $(window),\n            body: $(document.body),\n            input: $(input),\n            cont: null,\n            rs: null,\n            min: null,\n            max: null,\n            from: null,\n            to: null,\n            single: null,\n            bar: null,\n            line: null,\n            s_single: null,\n            s_from: null,\n            s_to: null,\n            shad_single: null,\n            shad_from: null,\n            shad_to: null,\n            edge: null,\n            grid: null,\n            grid_labels: []\n        };\n\n        // storage for measure variables\n        this.coords = {\n            // left\n            x_gap: 0,\n            x_pointer: 0,\n\n            // width\n            w_rs: 0,\n            w_rs_old: 0,\n            w_handle: 0,\n\n            // percents\n            p_gap: 0,\n            p_gap_left: 0,\n            p_gap_right: 0,\n            p_step: 0,\n            p_pointer: 0,\n            p_handle: 0,\n            p_single_fake: 0,\n            p_single_real: 0,\n            p_from_fake: 0,\n            p_from_real: 0,\n            p_to_fake: 0,\n            p_to_real: 0,\n            p_bar_x: 0,\n            p_bar_w: 0,\n\n            // grid\n            grid_gap: 0,\n            big_num: 0,\n            big: [],\n            big_w: [],\n            big_p: [],\n            big_x: []\n        };\n\n        // storage for labels measure variables\n        this.labels = {\n            // width\n            w_min: 0,\n            w_max: 0,\n            w_from: 0,\n            w_to: 0,\n            w_single: 0,\n\n            // percents\n            p_min: 0,\n            p_max: 0,\n            p_from_fake: 0,\n            p_from_left: 0,\n            p_to_fake: 0,\n            p_to_left: 0,\n            p_single_fake: 0,\n            p_single_left: 0\n        };\n\n\n\n        /**\n         * get and validate config\n         */\n        var $inp = this.$cache.input,\n            val = $inp.prop(\"value\"),\n            config, config_from_data, prop;\n\n        // default config\n        config = {\n            skin: \"flat\",\n            type: \"single\",\n\n            min: 10,\n            max: 100,\n            from: null,\n            to: null,\n            step: 1,\n\n            min_interval: 0,\n            max_interval: 0,\n            drag_interval: false,\n\n            values: [],\n            p_values: [],\n\n            from_fixed: false,\n            from_min: null,\n            from_max: null,\n            from_shadow: false,\n\n            to_fixed: false,\n            to_min: null,\n            to_max: null,\n            to_shadow: false,\n\n            prettify_enabled: true,\n            prettify_separator: \" \",\n            prettify: null,\n\n            force_edges: false,\n\n            keyboard: true,\n\n            grid: false,\n            grid_margin: true,\n            grid_num: 4,\n            grid_snap: false,\n\n            hide_min_max: false,\n            hide_from_to: false,\n\n            prefix: \"\",\n            postfix: \"\",\n            max_postfix: \"\",\n            decorate_both: true,\n            values_separator: \" — \",\n\n            input_values_separator: \";\",\n\n            disable: false,\n            block: false,\n\n            extra_classes: \"\",\n\n            scope: null,\n            onStart: null,\n            onChange: null,\n            onFinish: null,\n            onUpdate: null\n        };\n\n\n        // check if base element is input\n        if ($inp[0].nodeName !== \"INPUT\") {\n            console && console.warn && console.warn(\"Base element should be <input>!\", $inp[0]);\n        }\n\n\n        // config from data-attributes extends js config\n        config_from_data = {\n            skin: $inp.data(\"skin\"),\n            type: $inp.data(\"type\"),\n\n            min: $inp.data(\"min\"),\n            max: $inp.data(\"max\"),\n            from: $inp.data(\"from\"),\n            to: $inp.data(\"to\"),\n            step: $inp.data(\"step\"),\n\n            min_interval: $inp.data(\"minInterval\"),\n            max_interval: $inp.data(\"maxInterval\"),\n            drag_interval: $inp.data(\"dragInterval\"),\n\n            values: $inp.data(\"values\"),\n\n            from_fixed: $inp.data(\"fromFixed\"),\n            from_min: $inp.data(\"fromMin\"),\n            from_max: $inp.data(\"fromMax\"),\n            from_shadow: $inp.data(\"fromShadow\"),\n\n            to_fixed: $inp.data(\"toFixed\"),\n            to_min: $inp.data(\"toMin\"),\n            to_max: $inp.data(\"toMax\"),\n            to_shadow: $inp.data(\"toShadow\"),\n\n            prettify_enabled: $inp.data(\"prettifyEnabled\"),\n            prettify_separator: $inp.data(\"prettifySeparator\"),\n\n            force_edges: $inp.data(\"forceEdges\"),\n\n            keyboard: $inp.data(\"keyboard\"),\n\n            grid: $inp.data(\"grid\"),\n            grid_margin: $inp.data(\"gridMargin\"),\n            grid_num: $inp.data(\"gridNum\"),\n            grid_snap: $inp.data(\"gridSnap\"),\n\n            hide_min_max: $inp.data(\"hideMinMax\"),\n            hide_from_to: $inp.data(\"hideFromTo\"),\n\n            prefix: $inp.data(\"prefix\"),\n            postfix: $inp.data(\"postfix\"),\n            max_postfix: $inp.data(\"maxPostfix\"),\n            decorate_both: $inp.data(\"decorateBoth\"),\n            values_separator: $inp.data(\"valuesSeparator\"),\n\n            input_values_separator: $inp.data(\"inputValuesSeparator\"),\n\n            disable: $inp.data(\"disable\"),\n            block: $inp.data(\"block\"),\n\n            extra_classes: $inp.data(\"extraClasses\"),\n        };\n        config_from_data.values = config_from_data.values && config_from_data.values.split(\",\");\n\n        for (prop in config_from_data) {\n            if (config_from_data.hasOwnProperty(prop)) {\n                if (config_from_data[prop] === undefined || config_from_data[prop] === \"\") {\n                    delete config_from_data[prop];\n                }\n            }\n        }\n\n\n        // input value extends default config\n        if (val !== undefined && val !== \"\") {\n            val = val.split(config_from_data.input_values_separator || options.input_values_separator || \";\");\n\n            if (val[0] && val[0] == +val[0]) {\n                val[0] = +val[0];\n            }\n            if (val[1] && val[1] == +val[1]) {\n                val[1] = +val[1];\n            }\n\n            if (options && options.values && options.values.length) {\n                config.from = val[0] && options.values.indexOf(val[0]);\n                config.to = val[1] && options.values.indexOf(val[1]);\n            } else {\n                config.from = val[0] && +val[0];\n                config.to = val[1] && +val[1];\n            }\n        }\n\n\n\n        // js config extends default config\n        $.extend(config, options);\n\n\n        // data config extends config\n        $.extend(config, config_from_data);\n        this.options = config;\n\n\n\n        // validate config, to be sure that all data types are correct\n        this.update_check = {};\n        this.validate();\n\n\n\n        // default result object, returned to callbacks\n        this.result = {\n            input: this.$cache.input,\n            slider: null,\n\n            min: this.options.min,\n            max: this.options.max,\n\n            from: this.options.from,\n            from_percent: 0,\n            from_value: null,\n\n            to: this.options.to,\n            to_percent: 0,\n            to_value: null\n        };\n\n\n\n        this.init();\n    };\n\n    IonRangeSlider.prototype = {\n\n        /**\n         * Starts or updates the plugin instance\n         *\n         * @param [is_update] {boolean}\n         */\n        init: function (is_update) {\n            this.no_diapason = false;\n            this.coords.p_step = this.convertToPercent(this.options.step, true);\n\n            this.target = \"base\";\n\n            this.toggleInput();\n            this.append();\n            this.setMinMax();\n\n            if (is_update) {\n                this.force_redraw = true;\n                this.calc(true);\n\n                // callbacks called\n                this.callOnUpdate();\n            } else {\n                this.force_redraw = true;\n                this.calc(true);\n\n                // callbacks called\n                this.callOnStart();\n            }\n\n            this.updateScene();\n        },\n\n        /**\n         * Appends slider template to a DOM\n         */\n        append: function () {\n            var container_html = '<span class=\"irs irs--' + this.options.skin + ' js-irs-' + this.plugin_count + ' ' + this.options.extra_classes + '\"></span>';\n            this.$cache.input.before(container_html);\n            this.$cache.input.prop(\"readonly\", true);\n            this.$cache.cont = this.$cache.input.prev();\n            this.result.slider = this.$cache.cont;\n\n            this.$cache.cont.html(base_html);\n            this.$cache.rs = this.$cache.cont.find(\".irs\");\n            this.$cache.min = this.$cache.cont.find(\".irs-min\");\n            this.$cache.max = this.$cache.cont.find(\".irs-max\");\n            this.$cache.from = this.$cache.cont.find(\".irs-from\");\n            this.$cache.to = this.$cache.cont.find(\".irs-to\");\n            this.$cache.single = this.$cache.cont.find(\".irs-single\");\n            this.$cache.line = this.$cache.cont.find(\".irs-line\");\n            this.$cache.grid = this.$cache.cont.find(\".irs-grid\");\n\n            if (this.options.type === \"single\") {\n                this.$cache.cont.append(single_html);\n                this.$cache.bar = this.$cache.cont.find(\".irs-bar\");\n                this.$cache.edge = this.$cache.cont.find(\".irs-bar-edge\");\n                this.$cache.s_single = this.$cache.cont.find(\".single\");\n                this.$cache.from[0].style.visibility = \"hidden\";\n                this.$cache.to[0].style.visibility = \"hidden\";\n                this.$cache.shad_single = this.$cache.cont.find(\".shadow-single\");\n            } else {\n                this.$cache.cont.append(double_html);\n                this.$cache.bar = this.$cache.cont.find(\".irs-bar\");\n                this.$cache.s_from = this.$cache.cont.find(\".from\");\n                this.$cache.s_to = this.$cache.cont.find(\".to\");\n                this.$cache.shad_from = this.$cache.cont.find(\".shadow-from\");\n                this.$cache.shad_to = this.$cache.cont.find(\".shadow-to\");\n\n                this.setTopHandler();\n            }\n\n            if (this.options.hide_from_to) {\n                this.$cache.from[0].style.display = \"none\";\n                this.$cache.to[0].style.display = \"none\";\n                this.$cache.single[0].style.display = \"none\";\n            }\n\n            this.appendGrid();\n\n            if (this.options.disable) {\n                this.appendDisableMask();\n                this.$cache.input[0].disabled = true;\n            } else {\n                this.$cache.input[0].disabled = false;\n                this.removeDisableMask();\n                this.bindEvents();\n            }\n\n            // block only if not disabled\n            if (!this.options.disable) {\n                if (this.options.block) {\n                    this.appendDisableMask();\n                } else {\n                    this.removeDisableMask();\n                }\n            }\n\n            if (this.options.drag_interval) {\n                this.$cache.bar[0].style.cursor = \"ew-resize\";\n            }\n        },\n\n        /**\n         * Determine which handler has a priority\n         * works only for double slider type\n         */\n        setTopHandler: function () {\n            var min = this.options.min,\n                max = this.options.max,\n                from = this.options.from,\n                to = this.options.to;\n\n            if (from > min && to === max) {\n                this.$cache.s_from.addClass(\"type_last\");\n            } else if (to < max) {\n                this.$cache.s_to.addClass(\"type_last\");\n            }\n        },\n\n        /**\n         * Determine which handles was clicked last\n         * and which handler should have hover effect\n         *\n         * @param target {String}\n         */\n        changeLevel: function (target) {\n            switch (target) {\n                case \"single\":\n                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake);\n                    this.$cache.s_single.addClass(\"state_hover\");\n                    break;\n                case \"from\":\n                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);\n                    this.$cache.s_from.addClass(\"state_hover\");\n                    this.$cache.s_from.addClass(\"type_last\");\n                    this.$cache.s_to.removeClass(\"type_last\");\n                    break;\n                case \"to\":\n                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake);\n                    this.$cache.s_to.addClass(\"state_hover\");\n                    this.$cache.s_to.addClass(\"type_last\");\n                    this.$cache.s_from.removeClass(\"type_last\");\n                    break;\n                case \"both\":\n                    this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);\n                    this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer);\n                    this.$cache.s_to.removeClass(\"type_last\");\n                    this.$cache.s_from.removeClass(\"type_last\");\n                    break;\n            }\n        },\n\n        /**\n         * Then slider is disabled\n         * appends extra layer with opacity\n         */\n        appendDisableMask: function () {\n            this.$cache.cont.append(disable_html);\n            this.$cache.cont.addClass(\"irs-disabled\");\n        },\n\n        /**\n         * Then slider is not disabled\n         * remove disable mask\n         */\n        removeDisableMask: function () {\n            this.$cache.cont.remove(\".irs-disable-mask\");\n            this.$cache.cont.removeClass(\"irs-disabled\");\n        },\n\n        /**\n         * Remove slider instance\n         * and unbind all events\n         */\n        remove: function () {\n            this.$cache.cont.remove();\n            this.$cache.cont = null;\n\n            this.$cache.line.off(\"keydown.irs_\" + this.plugin_count);\n\n            this.$cache.body.off(\"touchmove.irs_\" + this.plugin_count);\n            this.$cache.body.off(\"mousemove.irs_\" + this.plugin_count);\n\n            this.$cache.win.off(\"touchend.irs_\" + this.plugin_count);\n            this.$cache.win.off(\"mouseup.irs_\" + this.plugin_count);\n\n            if (is_old_ie) {\n                this.$cache.body.off(\"mouseup.irs_\" + this.plugin_count);\n                this.$cache.body.off(\"mouseleave.irs_\" + this.plugin_count);\n            }\n\n            this.$cache.grid_labels = [];\n            this.coords.big = [];\n            this.coords.big_w = [];\n            this.coords.big_p = [];\n            this.coords.big_x = [];\n\n            cancelAnimationFrame(this.raf_id);\n        },\n\n        /**\n         * bind all slider events\n         */\n        bindEvents: function () {\n            if (this.no_diapason) {\n                return;\n            }\n\n            this.$cache.body.on(\"touchmove.irs_\" + this.plugin_count, this.pointerMove.bind(this));\n            this.$cache.body.on(\"mousemove.irs_\" + this.plugin_count, this.pointerMove.bind(this));\n\n            this.$cache.win.on(\"touchend.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n            this.$cache.win.on(\"mouseup.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n\n            this.$cache.line.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n            this.$cache.line.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n\n            this.$cache.line.on(\"focus.irs_\" + this.plugin_count, this.pointerFocus.bind(this));\n\n            if (this.options.drag_interval && this.options.type === \"double\") {\n                this.$cache.bar.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"both\"));\n                this.$cache.bar.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"both\"));\n            } else {\n                this.$cache.bar.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n                this.$cache.bar.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n            }\n\n            if (this.options.type === \"single\") {\n                this.$cache.single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n                this.$cache.s_single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n                this.$cache.shad_single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n\n                this.$cache.single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n                this.$cache.s_single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"single\"));\n                this.$cache.edge.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n                this.$cache.shad_single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n            } else {\n                this.$cache.single.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, null));\n                this.$cache.single.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, null));\n\n                this.$cache.from.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n                this.$cache.s_from.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n                this.$cache.to.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n                this.$cache.s_to.on(\"touchstart.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n                this.$cache.shad_from.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n                this.$cache.shad_to.on(\"touchstart.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n\n                this.$cache.from.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n                this.$cache.s_from.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"from\"));\n                this.$cache.to.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n                this.$cache.s_to.on(\"mousedown.irs_\" + this.plugin_count, this.pointerDown.bind(this, \"to\"));\n                this.$cache.shad_from.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n                this.$cache.shad_to.on(\"mousedown.irs_\" + this.plugin_count, this.pointerClick.bind(this, \"click\"));\n            }\n\n            if (this.options.keyboard) {\n                this.$cache.line.on(\"keydown.irs_\" + this.plugin_count, this.key.bind(this, \"keyboard\"));\n            }\n\n            if (is_old_ie) {\n                this.$cache.body.on(\"mouseup.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n                this.$cache.body.on(\"mouseleave.irs_\" + this.plugin_count, this.pointerUp.bind(this));\n            }\n        },\n\n        /**\n         * Focus with tabIndex\n         *\n         * @param e {Object} event object\n         */\n        pointerFocus: function (e) {\n            if (!this.target) {\n                var x;\n                var $handle;\n\n                if (this.options.type === \"single\") {\n                    $handle = this.$cache.single;\n                } else {\n                    $handle = this.$cache.from;\n                }\n\n                x = $handle.offset().left;\n                x += ($handle.width() / 2) - 1;\n\n                this.pointerClick(\"single\", {preventDefault: function () {}, pageX: x});\n            }\n        },\n\n        /**\n         * Mousemove or touchmove\n         * only for handlers\n         *\n         * @param e {Object} event object\n         */\n        pointerMove: function (e) {\n            if (!this.dragging) {\n                return;\n            }\n\n            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;\n            this.coords.x_pointer = x - this.coords.x_gap;\n\n            this.calc();\n        },\n\n        /**\n         * Mouseup or touchend\n         * only for handlers\n         *\n         * @param e {Object} event object\n         */\n        pointerUp: function (e) {\n            if (this.current_plugin !== this.plugin_count) {\n                return;\n            }\n\n            if (this.is_active) {\n                this.is_active = false;\n            } else {\n                return;\n            }\n\n            this.$cache.cont.find(\".state_hover\").removeClass(\"state_hover\");\n\n            this.force_redraw = true;\n\n            if (is_old_ie) {\n                $(\"*\").prop(\"unselectable\", false);\n            }\n\n            this.updateScene();\n            this.restoreOriginalMinInterval();\n\n            // callbacks call\n            if ($.contains(this.$cache.cont[0], e.target) || this.dragging) {\n                this.callOnFinish();\n            }\n\n            this.dragging = false;\n        },\n\n        /**\n         * Mousedown or touchstart\n         * only for handlers\n         *\n         * @param target {String|null}\n         * @param e {Object} event object\n         */\n        pointerDown: function (target, e) {\n            e.preventDefault();\n            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;\n            if (e.button === 2) {\n                return;\n            }\n\n            if (target === \"both\") {\n                this.setTempMinInterval();\n            }\n\n            if (!target) {\n                target = this.target || \"from\";\n            }\n\n            this.current_plugin = this.plugin_count;\n            this.target = target;\n\n            this.is_active = true;\n            this.dragging = true;\n\n            this.coords.x_gap = this.$cache.rs.offset().left;\n            this.coords.x_pointer = x - this.coords.x_gap;\n\n            this.calcPointerPercent();\n            this.changeLevel(target);\n\n            if (is_old_ie) {\n                $(\"*\").prop(\"unselectable\", true);\n            }\n\n            this.$cache.line.trigger(\"focus\");\n\n            this.updateScene();\n        },\n\n        /**\n         * Mousedown or touchstart\n         * for other slider elements, like diapason line\n         *\n         * @param target {String}\n         * @param e {Object} event object\n         */\n        pointerClick: function (target, e) {\n            e.preventDefault();\n            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;\n            if (e.button === 2) {\n                return;\n            }\n\n            this.current_plugin = this.plugin_count;\n            this.target = target;\n\n            this.is_click = true;\n            this.coords.x_gap = this.$cache.rs.offset().left;\n            this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();\n\n            this.force_redraw = true;\n            this.calc();\n\n            this.$cache.line.trigger(\"focus\");\n        },\n\n        /**\n         * Keyborard controls for focused slider\n         *\n         * @param target {String}\n         * @param e {Object} event object\n         * @returns {boolean|undefined}\n         */\n        key: function (target, e) {\n            if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {\n                return;\n            }\n\n            switch (e.which) {\n                case 83: // W\n                case 65: // A\n                case 40: // DOWN\n                case 37: // LEFT\n                    e.preventDefault();\n                    this.moveByKey(false);\n                    break;\n\n                case 87: // S\n                case 68: // D\n                case 38: // UP\n                case 39: // RIGHT\n                    e.preventDefault();\n                    this.moveByKey(true);\n                    break;\n            }\n\n            return true;\n        },\n\n        /**\n         * Move by key\n         *\n         * @param right {boolean} direction to move\n         */\n        moveByKey: function (right) {\n            var p = this.coords.p_pointer;\n            var p_step = (this.options.max - this.options.min) / 100;\n            p_step = this.options.step / p_step;\n\n            if (right) {\n                p += p_step;\n            } else {\n                p -= p_step;\n            }\n\n            this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);\n            this.is_key = true;\n            this.calc();\n        },\n\n        /**\n         * Set visibility and content\n         * of Min and Max labels\n         */\n        setMinMax: function () {\n            if (!this.options) {\n                return;\n            }\n\n            if (this.options.hide_min_max) {\n                this.$cache.min[0].style.display = \"none\";\n                this.$cache.max[0].style.display = \"none\";\n                return;\n            }\n\n            if (this.options.values.length) {\n                this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));\n                this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));\n            } else {\n                var min_pretty = this._prettify(this.options.min);\n                var max_pretty = this._prettify(this.options.max);\n\n                this.result.min_pretty = min_pretty;\n                this.result.max_pretty = max_pretty;\n\n                this.$cache.min.html(this.decorate(min_pretty, this.options.min));\n                this.$cache.max.html(this.decorate(max_pretty, this.options.max));\n            }\n\n            this.labels.w_min = this.$cache.min.outerWidth(false);\n            this.labels.w_max = this.$cache.max.outerWidth(false);\n        },\n\n        /**\n         * Then dragging interval, prevent interval collapsing\n         * using min_interval option\n         */\n        setTempMinInterval: function () {\n            var interval = this.result.to - this.result.from;\n\n            if (this.old_min_interval === null) {\n                this.old_min_interval = this.options.min_interval;\n            }\n\n            this.options.min_interval = interval;\n        },\n\n        /**\n         * Restore min_interval option to original\n         */\n        restoreOriginalMinInterval: function () {\n            if (this.old_min_interval !== null) {\n                this.options.min_interval = this.old_min_interval;\n                this.old_min_interval = null;\n            }\n        },\n\n\n\n        // =============================================================================================================\n        // Calculations\n\n        /**\n         * All calculations and measures start here\n         *\n         * @param update {boolean=}\n         */\n        calc: function (update) {\n            if (!this.options) {\n                return;\n            }\n\n            this.calc_count++;\n\n            if (this.calc_count === 10 || update) {\n                this.calc_count = 0;\n                this.coords.w_rs = this.$cache.rs.outerWidth(false);\n\n                this.calcHandlePercent();\n            }\n\n            if (!this.coords.w_rs) {\n                return;\n            }\n\n            this.calcPointerPercent();\n            var handle_x = this.getHandleX();\n\n\n            if (this.target === \"both\") {\n                this.coords.p_gap = 0;\n                handle_x = this.getHandleX();\n            }\n\n            if (this.target === \"click\") {\n                this.coords.p_gap = this.coords.p_handle / 2;\n                handle_x = this.getHandleX();\n\n                if (this.options.drag_interval) {\n                    this.target = \"both_one\";\n                } else {\n                    this.target = this.chooseHandle(handle_x);\n                }\n            }\n\n            switch (this.target) {\n                case \"base\":\n                    var w = (this.options.max - this.options.min) / 100,\n                        f = (this.result.from - this.options.min) / w,\n                        t = (this.result.to - this.options.min) / w;\n\n                    this.coords.p_single_real = this.toFixed(f);\n                    this.coords.p_from_real = this.toFixed(f);\n                    this.coords.p_to_real = this.toFixed(t);\n\n                    this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);\n                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n\n                    this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);\n                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n\n                    this.target = null;\n\n                    break;\n\n                case \"single\":\n                    if (this.options.from_fixed) {\n                        break;\n                    }\n\n                    this.coords.p_single_real = this.convertToRealPercent(handle_x);\n                    this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real);\n                    this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);\n\n                    this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);\n\n                    break;\n\n                case \"from\":\n                    if (this.options.from_fixed) {\n                        break;\n                    }\n\n                    this.coords.p_from_real = this.convertToRealPercent(handle_x);\n                    this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);\n                    if (this.coords.p_from_real > this.coords.p_to_real) {\n                        this.coords.p_from_real = this.coords.p_to_real;\n                    }\n                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n                    this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, \"from\");\n                    this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, \"from\");\n\n                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n\n                    break;\n\n                case \"to\":\n                    if (this.options.to_fixed) {\n                        break;\n                    }\n\n                    this.coords.p_to_real = this.convertToRealPercent(handle_x);\n                    this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);\n                    if (this.coords.p_to_real < this.coords.p_from_real) {\n                        this.coords.p_to_real = this.coords.p_from_real;\n                    }\n                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n                    this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, \"to\");\n                    this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, \"to\");\n\n                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n\n                    break;\n\n                case \"both\":\n                    if (this.options.from_fixed || this.options.to_fixed) {\n                        break;\n                    }\n\n                    handle_x = this.toFixed(handle_x + (this.coords.p_handle * 0.001));\n\n                    this.coords.p_from_real = this.convertToRealPercent(handle_x) - this.coords.p_gap_left;\n                    this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);\n                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n                    this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, \"from\");\n                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n\n                    this.coords.p_to_real = this.convertToRealPercent(handle_x) + this.coords.p_gap_right;\n                    this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);\n                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n                    this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, \"to\");\n                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n\n                    break;\n\n                case \"both_one\":\n                    if (this.options.from_fixed || this.options.to_fixed) {\n                        break;\n                    }\n\n                    var real_x = this.convertToRealPercent(handle_x),\n                        from = this.result.from_percent,\n                        to = this.result.to_percent,\n                        full = to - from,\n                        half = full / 2,\n                        new_from = real_x - half,\n                        new_to = real_x + half;\n\n                    if (new_from < 0) {\n                        new_from = 0;\n                        new_to = new_from + full;\n                    }\n\n                    if (new_to > 100) {\n                        new_to = 100;\n                        new_from = new_to - full;\n                    }\n\n                    this.coords.p_from_real = this.calcWithStep(new_from);\n                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);\n                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);\n\n                    this.coords.p_to_real = this.calcWithStep(new_to);\n                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);\n                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);\n\n                    break;\n            }\n\n            if (this.options.type === \"single\") {\n                this.coords.p_bar_x = (this.coords.p_handle / 2);\n                this.coords.p_bar_w = this.coords.p_single_fake;\n\n                this.result.from_percent = this.coords.p_single_real;\n                this.result.from = this.convertToValue(this.coords.p_single_real);\n                this.result.from_pretty = this._prettify(this.result.from);\n\n                if (this.options.values.length) {\n                    this.result.from_value = this.options.values[this.result.from];\n                }\n            } else {\n                this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + (this.coords.p_handle / 2));\n                this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake);\n\n                this.result.from_percent = this.coords.p_from_real;\n                this.result.from = this.convertToValue(this.coords.p_from_real);\n                this.result.from_pretty = this._prettify(this.result.from);\n                this.result.to_percent = this.coords.p_to_real;\n                this.result.to = this.convertToValue(this.coords.p_to_real);\n                this.result.to_pretty = this._prettify(this.result.to);\n\n                if (this.options.values.length) {\n                    this.result.from_value = this.options.values[this.result.from];\n                    this.result.to_value = this.options.values[this.result.to];\n                }\n            }\n\n            this.calcMinMax();\n            this.calcLabels();\n        },\n\n\n        /**\n         * calculates pointer X in percent\n         */\n        calcPointerPercent: function () {\n            if (!this.coords.w_rs) {\n                this.coords.p_pointer = 0;\n                return;\n            }\n\n            if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)  ) {\n                this.coords.x_pointer = 0;\n            } else if (this.coords.x_pointer > this.coords.w_rs) {\n                this.coords.x_pointer = this.coords.w_rs;\n            }\n\n            this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);\n        },\n\n        convertToRealPercent: function (fake) {\n            var full = 100 - this.coords.p_handle;\n            return fake / full * 100;\n        },\n\n        convertToFakePercent: function (real) {\n            var full = 100 - this.coords.p_handle;\n            return real / 100 * full;\n        },\n\n        getHandleX: function () {\n            var max = 100 - this.coords.p_handle,\n                x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);\n\n            if (x < 0) {\n                x = 0;\n            } else if (x > max) {\n                x = max;\n            }\n\n            return x;\n        },\n\n        calcHandlePercent: function () {\n            if (this.options.type === \"single\") {\n                this.coords.w_handle = this.$cache.s_single.outerWidth(false);\n            } else {\n                this.coords.w_handle = this.$cache.s_from.outerWidth(false);\n            }\n\n            this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);\n        },\n\n        /**\n         * Find closest handle to pointer click\n         *\n         * @param real_x {Number}\n         * @returns {String}\n         */\n        chooseHandle: function (real_x) {\n            if (this.options.type === \"single\") {\n                return \"single\";\n            } else {\n                var m_point = this.coords.p_from_real + ((this.coords.p_to_real - this.coords.p_from_real) / 2);\n                if (real_x >= m_point) {\n                    return this.options.to_fixed ? \"from\" : \"to\";\n                } else {\n                    return this.options.from_fixed ? \"to\" : \"from\";\n                }\n            }\n        },\n\n        /**\n         * Measure Min and Max labels width in percent\n         */\n        calcMinMax: function () {\n            if (!this.coords.w_rs) {\n                return;\n            }\n\n            this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;\n            this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;\n        },\n\n        /**\n         * Measure labels width and X in percent\n         */\n        calcLabels: function () {\n            if (!this.coords.w_rs || this.options.hide_from_to) {\n                return;\n            }\n\n            if (this.options.type === \"single\") {\n\n                this.labels.w_single = this.$cache.single.outerWidth(false);\n                this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;\n                this.labels.p_single_left = this.coords.p_single_fake + (this.coords.p_handle / 2) - (this.labels.p_single_fake / 2);\n                this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);\n\n            } else {\n\n                this.labels.w_from = this.$cache.from.outerWidth(false);\n                this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100;\n                this.labels.p_from_left = this.coords.p_from_fake + (this.coords.p_handle / 2) - (this.labels.p_from_fake / 2);\n                this.labels.p_from_left = this.toFixed(this.labels.p_from_left);\n                this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake);\n\n                this.labels.w_to = this.$cache.to.outerWidth(false);\n                this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100;\n                this.labels.p_to_left = this.coords.p_to_fake + (this.coords.p_handle / 2) - (this.labels.p_to_fake / 2);\n                this.labels.p_to_left = this.toFixed(this.labels.p_to_left);\n                this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake);\n\n                this.labels.w_single = this.$cache.single.outerWidth(false);\n                this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;\n                this.labels.p_single_left = ((this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2) - (this.labels.p_single_fake / 2);\n                this.labels.p_single_left = this.toFixed(this.labels.p_single_left);\n                this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);\n\n            }\n        },\n\n\n\n        // =============================================================================================================\n        // Drawings\n\n        /**\n         * Main function called in request animation frame\n         * to update everything\n         */\n        updateScene: function () {\n            if (this.raf_id) {\n                cancelAnimationFrame(this.raf_id);\n                this.raf_id = null;\n            }\n\n            clearTimeout(this.update_tm);\n            this.update_tm = null;\n\n            if (!this.options) {\n                return;\n            }\n\n            this.drawHandles();\n\n            if (this.is_active) {\n                this.raf_id = requestAnimationFrame(this.updateScene.bind(this));\n            } else {\n                this.update_tm = setTimeout(this.updateScene.bind(this), 300);\n            }\n        },\n\n        /**\n         * Draw handles\n         */\n        drawHandles: function () {\n            this.coords.w_rs = this.$cache.rs.outerWidth(false);\n\n            if (!this.coords.w_rs) {\n                return;\n            }\n\n            if (this.coords.w_rs !== this.coords.w_rs_old) {\n                this.target = \"base\";\n                this.is_resize = true;\n            }\n\n            if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {\n                this.setMinMax();\n                this.calc(true);\n                this.drawLabels();\n                if (this.options.grid) {\n                    this.calcGridMargin();\n                    this.calcGridLabels();\n                }\n                this.force_redraw = true;\n                this.coords.w_rs_old = this.coords.w_rs;\n                this.drawShadow();\n            }\n\n            if (!this.coords.w_rs) {\n                return;\n            }\n\n            if (!this.dragging && !this.force_redraw && !this.is_key) {\n                return;\n            }\n\n            if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {\n\n                this.drawLabels();\n\n                this.$cache.bar[0].style.left = this.coords.p_bar_x + \"%\";\n                this.$cache.bar[0].style.width = this.coords.p_bar_w + \"%\";\n\n                if (this.options.type === \"single\") {\n                    this.$cache.bar[0].style.left = 0;\n                    this.$cache.bar[0].style.width = this.coords.p_bar_w + this.coords.p_bar_x + \"%\";\n\n                    this.$cache.s_single[0].style.left = this.coords.p_single_fake + \"%\";\n\n                    this.$cache.single[0].style.left = this.labels.p_single_left + \"%\";\n                } else {\n                    this.$cache.s_from[0].style.left = this.coords.p_from_fake + \"%\";\n                    this.$cache.s_to[0].style.left = this.coords.p_to_fake + \"%\";\n\n                    if (this.old_from !== this.result.from || this.force_redraw) {\n                        this.$cache.from[0].style.left = this.labels.p_from_left + \"%\";\n                    }\n                    if (this.old_to !== this.result.to || this.force_redraw) {\n                        this.$cache.to[0].style.left = this.labels.p_to_left + \"%\";\n                    }\n\n                    this.$cache.single[0].style.left = this.labels.p_single_left + \"%\";\n                }\n\n                this.writeToInput();\n\n                if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {\n                    this.$cache.input.trigger(\"change\");\n                    this.$cache.input.trigger(\"input\");\n                }\n\n                this.old_from = this.result.from;\n                this.old_to = this.result.to;\n\n                // callbacks call\n                if (!this.is_resize && !this.is_update && !this.is_start && !this.is_finish) {\n                    this.callOnChange();\n                }\n                if (this.is_key || this.is_click) {\n                    this.is_key = false;\n                    this.is_click = false;\n                    this.callOnFinish();\n                }\n\n                this.is_update = false;\n                this.is_resize = false;\n                this.is_finish = false;\n            }\n\n            this.is_start = false;\n            this.is_key = false;\n            this.is_click = false;\n            this.force_redraw = false;\n        },\n\n        /**\n         * Draw labels\n         * measure labels collisions\n         * collapse close labels\n         */\n        drawLabels: function () {\n            if (!this.options) {\n                return;\n            }\n\n            var values_num = this.options.values.length;\n            var p_values = this.options.p_values;\n            var text_single;\n            var text_from;\n            var text_to;\n            var from_pretty;\n            var to_pretty;\n\n            if (this.options.hide_from_to) {\n                return;\n            }\n\n            if (this.options.type === \"single\") {\n\n                if (values_num) {\n                    text_single = this.decorate(p_values[this.result.from]);\n                    this.$cache.single.html(text_single);\n                } else {\n                    from_pretty = this._prettify(this.result.from);\n\n                    text_single = this.decorate(from_pretty, this.result.from);\n                    this.$cache.single.html(text_single);\n                }\n\n                this.calcLabels();\n\n                if (this.labels.p_single_left < this.labels.p_min + 1) {\n                    this.$cache.min[0].style.visibility = \"hidden\";\n                } else {\n                    this.$cache.min[0].style.visibility = \"visible\";\n                }\n\n                if (this.labels.p_single_left + this.labels.p_single_fake > 100 - this.labels.p_max - 1) {\n                    this.$cache.max[0].style.visibility = \"hidden\";\n                } else {\n                    this.$cache.max[0].style.visibility = \"visible\";\n                }\n\n            } else {\n\n                if (values_num) {\n\n                    if (this.options.decorate_both) {\n                        text_single = this.decorate(p_values[this.result.from]);\n                        text_single += this.options.values_separator;\n                        text_single += this.decorate(p_values[this.result.to]);\n                    } else {\n                        text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);\n                    }\n                    text_from = this.decorate(p_values[this.result.from]);\n                    text_to = this.decorate(p_values[this.result.to]);\n\n                    this.$cache.single.html(text_single);\n                    this.$cache.from.html(text_from);\n                    this.$cache.to.html(text_to);\n\n                } else {\n                    from_pretty = this._prettify(this.result.from);\n                    to_pretty = this._prettify(this.result.to);\n\n                    if (this.options.decorate_both) {\n                        text_single = this.decorate(from_pretty, this.result.from);\n                        text_single += this.options.values_separator;\n                        text_single += this.decorate(to_pretty, this.result.to);\n                    } else {\n                        text_single = this.decorate(from_pretty + this.options.values_separator + to_pretty, this.result.to);\n                    }\n                    text_from = this.decorate(from_pretty, this.result.from);\n                    text_to = this.decorate(to_pretty, this.result.to);\n\n                    this.$cache.single.html(text_single);\n                    this.$cache.from.html(text_from);\n                    this.$cache.to.html(text_to);\n\n                }\n\n                this.calcLabels();\n\n                var min = Math.min(this.labels.p_single_left, this.labels.p_from_left),\n                    single_left = this.labels.p_single_left + this.labels.p_single_fake,\n                    to_left = this.labels.p_to_left + this.labels.p_to_fake,\n                    max = Math.max(single_left, to_left);\n\n                if (this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left) {\n                    this.$cache.from[0].style.visibility = \"hidden\";\n                    this.$cache.to[0].style.visibility = \"hidden\";\n                    this.$cache.single[0].style.visibility = \"visible\";\n\n                    if (this.result.from === this.result.to) {\n                        if (this.target === \"from\") {\n                            this.$cache.from[0].style.visibility = \"visible\";\n                        } else if (this.target === \"to\") {\n                            this.$cache.to[0].style.visibility = \"visible\";\n                        } else if (!this.target) {\n                            this.$cache.from[0].style.visibility = \"visible\";\n                        }\n                        this.$cache.single[0].style.visibility = \"hidden\";\n                        max = to_left;\n                    } else {\n                        this.$cache.from[0].style.visibility = \"hidden\";\n                        this.$cache.to[0].style.visibility = \"hidden\";\n                        this.$cache.single[0].style.visibility = \"visible\";\n                        max = Math.max(single_left, to_left);\n                    }\n                } else {\n                    this.$cache.from[0].style.visibility = \"visible\";\n                    this.$cache.to[0].style.visibility = \"visible\";\n                    this.$cache.single[0].style.visibility = \"hidden\";\n                }\n\n                if (min < this.labels.p_min + 1) {\n                    this.$cache.min[0].style.visibility = \"hidden\";\n                } else {\n                    this.$cache.min[0].style.visibility = \"visible\";\n                }\n\n                if (max > 100 - this.labels.p_max - 1) {\n                    this.$cache.max[0].style.visibility = \"hidden\";\n                } else {\n                    this.$cache.max[0].style.visibility = \"visible\";\n                }\n\n            }\n        },\n\n        /**\n         * Draw shadow intervals\n         */\n        drawShadow: function () {\n            var o = this.options,\n                c = this.$cache,\n\n                is_from_min = typeof o.from_min === \"number\" && !isNaN(o.from_min),\n                is_from_max = typeof o.from_max === \"number\" && !isNaN(o.from_max),\n                is_to_min = typeof o.to_min === \"number\" && !isNaN(o.to_min),\n                is_to_max = typeof o.to_max === \"number\" && !isNaN(o.to_max),\n\n                from_min,\n                from_max,\n                to_min,\n                to_max;\n\n            if (o.type === \"single\") {\n                if (o.from_shadow && (is_from_min || is_from_max)) {\n                    from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);\n                    from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;\n                    from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));\n                    from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));\n                    from_min = from_min + (this.coords.p_handle / 2);\n\n                    c.shad_single[0].style.display = \"block\";\n                    c.shad_single[0].style.left = from_min + \"%\";\n                    c.shad_single[0].style.width = from_max + \"%\";\n                } else {\n                    c.shad_single[0].style.display = \"none\";\n                }\n            } else {\n                if (o.from_shadow && (is_from_min || is_from_max)) {\n                    from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);\n                    from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;\n                    from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));\n                    from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));\n                    from_min = from_min + (this.coords.p_handle / 2);\n\n                    c.shad_from[0].style.display = \"block\";\n                    c.shad_from[0].style.left = from_min + \"%\";\n                    c.shad_from[0].style.width = from_max + \"%\";\n                } else {\n                    c.shad_from[0].style.display = \"none\";\n                }\n\n                if (o.to_shadow && (is_to_min || is_to_max)) {\n                    to_min = this.convertToPercent(is_to_min ? o.to_min : o.min);\n                    to_max = this.convertToPercent(is_to_max ? o.to_max : o.max) - to_min;\n                    to_min = this.toFixed(to_min - (this.coords.p_handle / 100 * to_min));\n                    to_max = this.toFixed(to_max - (this.coords.p_handle / 100 * to_max));\n                    to_min = to_min + (this.coords.p_handle / 2);\n\n                    c.shad_to[0].style.display = \"block\";\n                    c.shad_to[0].style.left = to_min + \"%\";\n                    c.shad_to[0].style.width = to_max + \"%\";\n                } else {\n                    c.shad_to[0].style.display = \"none\";\n                }\n            }\n        },\n\n\n\n        /**\n         * Write values to input element\n         */\n        writeToInput: function () {\n            if (this.options.type === \"single\") {\n                if (this.options.values.length) {\n                    this.$cache.input.prop(\"value\", this.result.from_value);\n                } else {\n                    this.$cache.input.prop(\"value\", this.result.from);\n                }\n                this.$cache.input.data(\"from\", this.result.from);\n            } else {\n                if (this.options.values.length) {\n                    this.$cache.input.prop(\"value\", this.result.from_value + this.options.input_values_separator + this.result.to_value);\n                } else {\n                    this.$cache.input.prop(\"value\", this.result.from + this.options.input_values_separator + this.result.to);\n                }\n                this.$cache.input.data(\"from\", this.result.from);\n                this.$cache.input.data(\"to\", this.result.to);\n            }\n        },\n\n\n\n        // =============================================================================================================\n        // Callbacks\n\n        callOnStart: function () {\n            this.writeToInput();\n\n            if (this.options.onStart && typeof this.options.onStart === \"function\") {\n                if (this.options.scope) {\n                    this.options.onStart.call(this.options.scope, this.result);\n                } else {\n                    this.options.onStart(this.result);\n                }\n            }\n        },\n        callOnChange: function () {\n            this.writeToInput();\n\n            if (this.options.onChange && typeof this.options.onChange === \"function\") {\n                if (this.options.scope) {\n                    this.options.onChange.call(this.options.scope, this.result);\n                } else {\n                    this.options.onChange(this.result);\n                }\n            }\n        },\n        callOnFinish: function () {\n            this.writeToInput();\n\n            if (this.options.onFinish && typeof this.options.onFinish === \"function\") {\n                if (this.options.scope) {\n                    this.options.onFinish.call(this.options.scope, this.result);\n                } else {\n                    this.options.onFinish(this.result);\n                }\n            }\n        },\n        callOnUpdate: function () {\n            this.writeToInput();\n\n            if (this.options.onUpdate && typeof this.options.onUpdate === \"function\") {\n                if (this.options.scope) {\n                    this.options.onUpdate.call(this.options.scope, this.result);\n                } else {\n                    this.options.onUpdate(this.result);\n                }\n            }\n        },\n\n\n\n\n        // =============================================================================================================\n        // Service methods\n\n        toggleInput: function () {\n            this.$cache.input.toggleClass(\"irs-hidden-input\");\n\n            if (this.has_tab_index) {\n                this.$cache.input.prop(\"tabindex\", -1);\n            } else {\n                this.$cache.input.removeProp(\"tabindex\");\n            }\n\n            this.has_tab_index = !this.has_tab_index;\n        },\n\n        /**\n         * Convert real value to percent\n         *\n         * @param value {Number} X in real\n         * @param no_min {boolean=} don't use min value\n         * @returns {Number} X in percent\n         */\n        convertToPercent: function (value, no_min) {\n            var diapason = this.options.max - this.options.min,\n                one_percent = diapason / 100,\n                val, percent;\n\n            if (!diapason) {\n                this.no_diapason = true;\n                return 0;\n            }\n\n            if (no_min) {\n                val = value;\n            } else {\n                val = value - this.options.min;\n            }\n\n            percent = val / one_percent;\n\n            return this.toFixed(percent);\n        },\n\n        /**\n         * Convert percent to real values\n         *\n         * @param percent {Number} X in percent\n         * @returns {Number} X in real\n         */\n        convertToValue: function (percent) {\n            var min = this.options.min,\n                max = this.options.max,\n                min_decimals = min.toString().split(\".\")[1],\n                max_decimals = max.toString().split(\".\")[1],\n                min_length, max_length,\n                avg_decimals = 0,\n                abs = 0;\n\n            if (percent === 0) {\n                return this.options.min;\n            }\n            if (percent === 100) {\n                return this.options.max;\n            }\n\n\n            if (min_decimals) {\n                min_length = min_decimals.length;\n                avg_decimals = min_length;\n            }\n            if (max_decimals) {\n                max_length = max_decimals.length;\n                avg_decimals = max_length;\n            }\n            if (min_length && max_length) {\n                avg_decimals = (min_length >= max_length) ? min_length : max_length;\n            }\n\n            if (min < 0) {\n                abs = Math.abs(min);\n                min = +(min + abs).toFixed(avg_decimals);\n                max = +(max + abs).toFixed(avg_decimals);\n            }\n\n            var number = ((max - min) / 100 * percent) + min,\n                string = this.options.step.toString().split(\".\")[1],\n                result;\n\n            if (string) {\n                number = +number.toFixed(string.length);\n            } else {\n                number = number / this.options.step;\n                number = number * this.options.step;\n\n                number = +number.toFixed(0);\n            }\n\n            if (abs) {\n                number -= abs;\n            }\n\n            if (string) {\n                result = +number.toFixed(string.length);\n            } else {\n                result = this.toFixed(number);\n            }\n\n            if (result < this.options.min) {\n                result = this.options.min;\n            } else if (result > this.options.max) {\n                result = this.options.max;\n            }\n\n            return result;\n        },\n\n        /**\n         * Round percent value with step\n         *\n         * @param percent {Number}\n         * @returns percent {Number} rounded\n         */\n        calcWithStep: function (percent) {\n            var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;\n\n            if (rounded > 100) {\n                rounded = 100;\n            }\n            if (percent === 100) {\n                rounded = 100;\n            }\n\n            return this.toFixed(rounded);\n        },\n\n        checkMinInterval: function (p_current, p_next, type) {\n            var o = this.options,\n                current,\n                next;\n\n            if (!o.min_interval) {\n                return p_current;\n            }\n\n            current = this.convertToValue(p_current);\n            next = this.convertToValue(p_next);\n\n            if (type === \"from\") {\n\n                if (next - current < o.min_interval) {\n                    current = next - o.min_interval;\n                }\n\n            } else {\n\n                if (current - next < o.min_interval) {\n                    current = next + o.min_interval;\n                }\n\n            }\n\n            return this.convertToPercent(current);\n        },\n\n        checkMaxInterval: function (p_current, p_next, type) {\n            var o = this.options,\n                current,\n                next;\n\n            if (!o.max_interval) {\n                return p_current;\n            }\n\n            current = this.convertToValue(p_current);\n            next = this.convertToValue(p_next);\n\n            if (type === \"from\") {\n\n                if (next - current > o.max_interval) {\n                    current = next - o.max_interval;\n                }\n\n            } else {\n\n                if (current - next > o.max_interval) {\n                    current = next + o.max_interval;\n                }\n\n            }\n\n            return this.convertToPercent(current);\n        },\n\n        checkDiapason: function (p_num, min, max) {\n            var num = this.convertToValue(p_num),\n                o = this.options;\n\n            if (typeof min !== \"number\") {\n                min = o.min;\n            }\n\n            if (typeof max !== \"number\") {\n                max = o.max;\n            }\n\n            if (num < min) {\n                num = min;\n            }\n\n            if (num > max) {\n                num = max;\n            }\n\n            return this.convertToPercent(num);\n        },\n\n        toFixed: function (num) {\n            num = num.toFixed(20);\n            return +num;\n        },\n\n        _prettify: function (num) {\n            if (!this.options.prettify_enabled) {\n                return num;\n            }\n\n            if (this.options.prettify && typeof this.options.prettify === \"function\") {\n                return this.options.prettify(num);\n            } else {\n                return this.prettify(num);\n            }\n        },\n\n        prettify: function (num) {\n            var n = num.toString();\n            return n.replace(/(\\d{1,3}(?=(?:\\d\\d\\d)+(?!\\d)))/g, \"$1\" + this.options.prettify_separator);\n        },\n\n        checkEdges: function (left, width) {\n            if (!this.options.force_edges) {\n                return this.toFixed(left);\n            }\n\n            if (left < 0) {\n                left = 0;\n            } else if (left > 100 - width) {\n                left = 100 - width;\n            }\n\n            return this.toFixed(left);\n        },\n\n        validate: function () {\n            var o = this.options,\n                r = this.result,\n                v = o.values,\n                vl = v.length,\n                value,\n                i;\n\n            if (typeof o.min === \"string\") o.min = +o.min;\n            if (typeof o.max === \"string\") o.max = +o.max;\n            if (typeof o.from === \"string\") o.from = +o.from;\n            if (typeof o.to === \"string\") o.to = +o.to;\n            if (typeof o.step === \"string\") o.step = +o.step;\n\n            if (typeof o.from_min === \"string\") o.from_min = +o.from_min;\n            if (typeof o.from_max === \"string\") o.from_max = +o.from_max;\n            if (typeof o.to_min === \"string\") o.to_min = +o.to_min;\n            if (typeof o.to_max === \"string\") o.to_max = +o.to_max;\n\n            if (typeof o.grid_num === \"string\") o.grid_num = +o.grid_num;\n\n            if (o.max < o.min) {\n                o.max = o.min;\n            }\n\n            if (vl) {\n                o.p_values = [];\n                o.min = 0;\n                o.max = vl - 1;\n                o.step = 1;\n                o.grid_num = o.max;\n                o.grid_snap = true;\n\n                for (i = 0; i < vl; i++) {\n                    value = +v[i];\n\n                    if (!isNaN(value)) {\n                        v[i] = value;\n                        value = this._prettify(value);\n                    } else {\n                        value = v[i];\n                    }\n\n                    o.p_values.push(value);\n                }\n            }\n\n            if (typeof o.from !== \"number\" || isNaN(o.from)) {\n                o.from = o.min;\n            }\n\n            if (typeof o.to !== \"number\" || isNaN(o.to)) {\n                o.to = o.max;\n            }\n\n            if (o.type === \"single\") {\n\n                if (o.from < o.min) o.from = o.min;\n                if (o.from > o.max) o.from = o.max;\n\n            } else {\n\n                if (o.from < o.min) o.from = o.min;\n                if (o.from > o.max) o.from = o.max;\n\n                if (o.to < o.min) o.to = o.min;\n                if (o.to > o.max) o.to = o.max;\n\n                if (this.update_check.from) {\n\n                    if (this.update_check.from !== o.from) {\n                        if (o.from > o.to) o.from = o.to;\n                    }\n                    if (this.update_check.to !== o.to) {\n                        if (o.to < o.from) o.to = o.from;\n                    }\n\n                }\n\n                if (o.from > o.to) o.from = o.to;\n                if (o.to < o.from) o.to = o.from;\n\n            }\n\n            if (typeof o.step !== \"number\" || isNaN(o.step) || !o.step || o.step < 0) {\n                o.step = 1;\n            }\n\n            if (typeof o.from_min === \"number\" && o.from < o.from_min) {\n                o.from = o.from_min;\n            }\n\n            if (typeof o.from_max === \"number\" && o.from > o.from_max) {\n                o.from = o.from_max;\n            }\n\n            if (typeof o.to_min === \"number\" && o.to < o.to_min) {\n                o.to = o.to_min;\n            }\n\n            if (typeof o.to_max === \"number\" && o.from > o.to_max) {\n                o.to = o.to_max;\n            }\n\n            if (r) {\n                if (r.min !== o.min) {\n                    r.min = o.min;\n                }\n\n                if (r.max !== o.max) {\n                    r.max = o.max;\n                }\n\n                if (r.from < r.min || r.from > r.max) {\n                    r.from = o.from;\n                }\n\n                if (r.to < r.min || r.to > r.max) {\n                    r.to = o.to;\n                }\n            }\n\n            if (typeof o.min_interval !== \"number\" || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {\n                o.min_interval = 0;\n            }\n\n            if (typeof o.max_interval !== \"number\" || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {\n                o.max_interval = 0;\n            }\n\n            if (o.min_interval && o.min_interval > o.max - o.min) {\n                o.min_interval = o.max - o.min;\n            }\n\n            if (o.max_interval && o.max_interval > o.max - o.min) {\n                o.max_interval = o.max - o.min;\n            }\n        },\n\n        decorate: function (num, original) {\n            var decorated = \"\",\n                o = this.options;\n\n            if (o.prefix) {\n                decorated += o.prefix;\n            }\n\n            decorated += num;\n\n            if (o.max_postfix) {\n                if (o.values.length && num === o.p_values[o.max]) {\n                    decorated += o.max_postfix;\n                    if (o.postfix) {\n                        decorated += \" \";\n                    }\n                } else if (original === o.max) {\n                    decorated += o.max_postfix;\n                    if (o.postfix) {\n                        decorated += \" \";\n                    }\n                }\n            }\n\n            if (o.postfix) {\n                decorated += o.postfix;\n            }\n\n            return decorated;\n        },\n\n        updateFrom: function () {\n            this.result.from = this.options.from;\n            this.result.from_percent = this.convertToPercent(this.result.from);\n            this.result.from_pretty = this._prettify(this.result.from);\n            if (this.options.values) {\n                this.result.from_value = this.options.values[this.result.from];\n            }\n        },\n\n        updateTo: function () {\n            this.result.to = this.options.to;\n            this.result.to_percent = this.convertToPercent(this.result.to);\n            this.result.to_pretty = this._prettify(this.result.to);\n            if (this.options.values) {\n                this.result.to_value = this.options.values[this.result.to];\n            }\n        },\n\n        updateResult: function () {\n            this.result.min = this.options.min;\n            this.result.max = this.options.max;\n            this.updateFrom();\n            this.updateTo();\n        },\n\n\n        // =============================================================================================================\n        // Grid\n\n        appendGrid: function () {\n            if (!this.options.grid) {\n                return;\n            }\n\n            var o = this.options,\n                i, z,\n\n                total = o.max - o.min,\n                big_num = o.grid_num,\n                big_p = 0,\n                big_w = 0,\n\n                small_max = 4,\n                local_small_max,\n                small_p,\n                small_w = 0,\n\n                result,\n                html = '';\n\n\n\n            this.calcGridMargin();\n\n            if (o.grid_snap) {\n                big_num = total / o.step;\n            }\n\n            if (big_num > 50) big_num = 50;\n            big_p = this.toFixed(100 / big_num);\n\n            if (big_num > 4) {\n                small_max = 3;\n            }\n            if (big_num > 7) {\n                small_max = 2;\n            }\n            if (big_num > 14) {\n                small_max = 1;\n            }\n            if (big_num > 28) {\n                small_max = 0;\n            }\n\n            for (i = 0; i < big_num + 1; i++) {\n                local_small_max = small_max;\n\n                big_w = this.toFixed(big_p * i);\n\n                if (big_w > 100) {\n                    big_w = 100;\n                }\n                this.coords.big[i] = big_w;\n\n                small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);\n\n                for (z = 1; z <= local_small_max; z++) {\n                    if (big_w === 0) {\n                        break;\n                    }\n\n                    small_w = this.toFixed(big_w - (small_p * z));\n\n                    html += '<span class=\"irs-grid-pol small\" style=\"left: ' + small_w + '%\"></span>';\n                }\n\n                html += '<span class=\"irs-grid-pol\" style=\"left: ' + big_w + '%\"></span>';\n\n                result = this.convertToValue(big_w);\n                if (o.values.length) {\n                    result = o.p_values[result];\n                } else {\n                    result = this._prettify(result);\n                }\n\n                html += '<span class=\"irs-grid-text js-grid-text-' + i + '\" style=\"left: ' + big_w + '%\">' + result + '</span>';\n            }\n            this.coords.big_num = Math.ceil(big_num + 1);\n\n\n\n            this.$cache.cont.addClass(\"irs-with-grid\");\n            this.$cache.grid.html(html);\n            this.cacheGridLabels();\n        },\n\n        cacheGridLabels: function () {\n            var $label, i,\n                num = this.coords.big_num;\n\n            for (i = 0; i < num; i++) {\n                $label = this.$cache.grid.find(\".js-grid-text-\" + i);\n                this.$cache.grid_labels.push($label);\n            }\n\n            this.calcGridLabels();\n        },\n\n        calcGridLabels: function () {\n            var i, label, start = [], finish = [],\n                num = this.coords.big_num;\n\n            for (i = 0; i < num; i++) {\n                this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);\n                this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);\n                this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);\n\n                start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);\n                finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);\n            }\n\n            if (this.options.force_edges) {\n                if (start[0] < -this.coords.grid_gap) {\n                    start[0] = -this.coords.grid_gap;\n                    finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);\n\n                    this.coords.big_x[0] = this.coords.grid_gap;\n                }\n\n                if (finish[num - 1] > 100 + this.coords.grid_gap) {\n                    finish[num - 1] = 100 + this.coords.grid_gap;\n                    start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);\n\n                    this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);\n                }\n            }\n\n            this.calcGridCollision(2, start, finish);\n            this.calcGridCollision(4, start, finish);\n\n            for (i = 0; i < num; i++) {\n                label = this.$cache.grid_labels[i][0];\n\n                if (this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {\n                    label.style.marginLeft = -this.coords.big_x[i] + \"%\";\n                }\n            }\n        },\n\n        // Collisions Calc Beta\n        // TODO: Refactor then have plenty of time\n        calcGridCollision: function (step, start, finish) {\n            var i, next_i, label,\n                num = this.coords.big_num;\n\n            for (i = 0; i < num; i += step) {\n                next_i = i + (step / 2);\n                if (next_i >= num) {\n                    break;\n                }\n\n                label = this.$cache.grid_labels[next_i][0];\n\n                if (finish[i] <= start[next_i]) {\n                    label.style.visibility = \"visible\";\n                } else {\n                    label.style.visibility = \"hidden\";\n                }\n            }\n        },\n\n        calcGridMargin: function () {\n            if (!this.options.grid_margin) {\n                return;\n            }\n\n            this.coords.w_rs = this.$cache.rs.outerWidth(false);\n            if (!this.coords.w_rs) {\n                return;\n            }\n\n            if (this.options.type === \"single\") {\n                this.coords.w_handle = this.$cache.s_single.outerWidth(false);\n            } else {\n                this.coords.w_handle = this.$cache.s_from.outerWidth(false);\n            }\n            this.coords.p_handle = this.toFixed(this.coords.w_handle  / this.coords.w_rs * 100);\n            this.coords.grid_gap = this.toFixed((this.coords.p_handle / 2) - 0.1);\n\n            this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + \"%\";\n            this.$cache.grid[0].style.left = this.coords.grid_gap + \"%\";\n        },\n\n\n\n        // =============================================================================================================\n        // Public methods\n\n        update: function (options) {\n            if (!this.input) {\n                return;\n            }\n\n            this.is_update = true;\n\n            this.options.from = this.result.from;\n            this.options.to = this.result.to;\n            this.update_check.from = this.result.from;\n            this.update_check.to = this.result.to;\n\n            this.options = $.extend(this.options, options);\n            this.validate();\n            this.updateResult(options);\n\n            this.toggleInput();\n            this.remove();\n            this.init(true);\n        },\n\n        reset: function () {\n            if (!this.input) {\n                return;\n            }\n\n            this.updateResult();\n            this.update();\n        },\n\n        destroy: function () {\n            if (!this.input) {\n                return;\n            }\n\n            this.toggleInput();\n            this.$cache.input.prop(\"readonly\", false);\n            $.data(this.input, \"ionRangeSlider\", null);\n\n            this.remove();\n            this.input = null;\n            this.options = null;\n        }\n    };\n\n    $.fn.ionRangeSlider = function (options) {\n        return this.each(function() {\n            if (!$.data(this, \"ionRangeSlider\")) {\n                $.data(this, \"ionRangeSlider\", new IonRangeSlider(this, options, plugin_count++));\n            }\n        });\n    };\n\n\n\n    // =================================================================================================================\n    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n    // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n    // MIT license\n\n    (function() {\n        var lastTime = 0;\n        var vendors = ['ms', 'moz', 'webkit', 'o'];\n        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']\n                || window[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n\n        if (!window.requestAnimationFrame)\n            window.requestAnimationFrame = function(callback, element) {\n                var currTime = new Date().getTime();\n                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n                var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n                    timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n\n        if (!window.cancelAnimationFrame)\n            window.cancelAnimationFrame = function(id) {\n                clearTimeout(id);\n            };\n    }());\n\n}));\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/***/ (function(module) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/ion-rangeslider/js/ion.rangeSlider.js":
/*!************************************************************!*\
  !*** ./node_modules/ion-rangeslider/js/ion.rangeSlider.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/ion-rangeslider/js/ion.rangeSlider.js */ "./node_modules/raw-loader/index.js!./node_modules/ion-rangeslider/js/ion.rangeSlider.js"))

/***/ }),

/***/ "./src/js/_components/_range.js":
/*!**************************************!*\
  !*** ./src/js/_components/_range.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var nodeModules_ion_rangeslider_js_ion_rangeSlider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nodeModules/ion-rangeslider/js/ion.rangeSlider.js */ "./node_modules/ion-rangeslider/js/ion.rangeSlider.js");
/* harmony import */ var nodeModules_ion_rangeslider_js_ion_rangeSlider_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nodeModules_ion_rangeslider_js_ion_rangeSlider_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!***********************************************!*\
  !*** ./src/entries/entry-ion-range-slider.js ***!
  \***********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _less_components_range_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../less/_components/_range.less */ "./src/less/_components/_range.less");
/* harmony import */ var _js_components_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../js/_components/_range.js */ "./src/js/_components/_range.js");
// Style


// Scripts

}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTJFLDBEQUEwRCxrQ0FBa0MsbUNBQW1DLG1EQUFtRCw0QkFBNEIsZ0JBQWdCLHVHQUF1RyxtQ0FBbUMsZ0JBQWdCLE9BQU8sSUFBSSxLQUFLLEdBQUc7Ozs7Ozs7Ozs7QUNBLzByRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQSxtQkFBTyxDQUFDLDhGQUF5RyxFQUFFLG1CQUFPLENBQUMsMExBQW9OOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVRUEvVTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQSxlQUFlLDRCQUE0QjtXQUMzQyxlQUFlO1dBQ2YsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBLDhDQUE4Qzs7Ozs7V0NBOUM7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ3lDOztBQUV6QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lc3NpYS8uL3NyYy9sZXNzL19jb21wb25lbnRzL19yYW5nZS5sZXNzPzg1YTEiLCJ3ZWJwYWNrOi8vbWVzc2lhLy4vbm9kZV9tb2R1bGVzL2lvbi1yYW5nZXNsaWRlci9qcy9pb24ucmFuZ2VTbGlkZXIuanMiLCJ3ZWJwYWNrOi8vbWVzc2lhLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovL21lc3NpYS8uL25vZGVfbW9kdWxlcy9pb24tcmFuZ2VzbGlkZXIvanMvaW9uLnJhbmdlU2xpZGVyLmpzP2MxN2YiLCJ3ZWJwYWNrOi8vbWVzc2lhLy4vc3JjL2pzL19jb21wb25lbnRzL19yYW5nZS5qcyIsIndlYnBhY2s6Ly9tZXNzaWEvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbWVzc2lhL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL21lc3NpYS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbWVzc2lhL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbWVzc2lhL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbWVzc2lhLy4vc3JjL2VudHJpZXMvZW50cnktaW9uLXJhbmdlLXNsaWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gSW9uLlJhbmdlU2xpZGVyXFxuLy8gdmVyc2lvbiAyLjMuMSBCdWlsZDogMzgyXFxuLy8gwqkgRGVuaXMgSW5lc2hpbiwgMjAxOVxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Jb25EZW5cXG4vL1xcbi8vIFByb2plY3QgcGFnZTogICAgaHR0cDovL2lvbmRlbi5jb20vYS9wbHVnaW5zL2lvbi5yYW5nZVNsaWRlci9lbi5odG1sXFxuLy8gR2l0SHViIHBhZ2U6ICAgICBodHRwczovL2dpdGh1Yi5jb20vSW9uRGVuL2lvbi5yYW5nZVNsaWRlclxcbi8vXFxuLy8gUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2U6XFxuLy8gaHR0cDovL2lvbmRlbi5jb20vYS9wbHVnaW5zL2xpY2VuY2UtZW4uaHRtbFxcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbjsoZnVuY3Rpb24oZmFjdG9yeSkge1xcbiAgICBpZiAoKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnIHx8ICFqUXVlcnkpICYmIHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAgICAgZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sIGZ1bmN0aW9uIChqUXVlcnkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShqUXVlcnksIGRvY3VtZW50LCB3aW5kb3csIG5hdmlnYXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGpRdWVyeSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWpRdWVyeSkgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICBmYWN0b3J5KHJlcXVpcmUoXFxcImpxdWVyeVxcXCIpLCBkb2N1bWVudCwgd2luZG93LCBuYXZpZ2F0b3IpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZmFjdG9yeShqUXVlcnksIGRvY3VtZW50LCB3aW5kb3csIG5hdmlnYXRvcik7XFxuICAgIH1cXG59IChmdW5jdGlvbiAoJCwgZG9jdW1lbnQsIHdpbmRvdywgbmF2aWdhdG9yLCB1bmRlZmluZWQpIHtcXG4gICAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICAvLyBTZXJ2aWNlXFxuXFxuICAgIHZhciBwbHVnaW5fY291bnQgPSAwO1xcblxcbiAgICAvLyBJRTggZml4XFxuICAgIHZhciBpc19vbGRfaWUgPSAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIG4gPSBuYXZpZ2F0b3IudXNlckFnZW50LFxcbiAgICAgICAgICAgIHIgPSAvbXNpZVxcXFxzXFxcXGQrL2ksXFxuICAgICAgICAgICAgdjtcXG4gICAgICAgIGlmIChuLnNlYXJjaChyKSA+IDApIHtcXG4gICAgICAgICAgICB2ID0gci5leGVjKG4pLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgdiA9IHYuc3BsaXQoXFxcIiBcXFwiKVsxXTtcXG4gICAgICAgICAgICBpZiAodiA8IDkpIHtcXG4gICAgICAgICAgICAgICAgJChcXFwiaHRtbFxcXCIpLmFkZENsYXNzKFxcXCJsdC1pZTlcXFwiKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9ICgpKTtcXG4gICAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcXG5cXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcXG4gICAgICAgICAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcXG5cXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICAgICAgICAgIGJvdW5kID0gZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24oKXt9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IG5ldyBGKCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgIHJldHVybiBib3VuZDtcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcXG4gICAgICAgICAgICB2YXIgaztcXG4gICAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJ0aGlzXFxcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xcbiAgICAgICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcXG4gICAgICAgICAgICBpZiAobGVuID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIG4gPSArZnJvbUluZGV4IHx8IDA7XFxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG4pID09PSBJbmZpbml0eSkge1xcbiAgICAgICAgICAgICAgICBuID0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG4gPj0gbGVuKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgayA9IE1hdGgubWF4KG4gPj0gMCA/IG4gOiBsZW4gLSBNYXRoLmFicyhuKSwgMCk7XFxuICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcXG4gICAgICAgICAgICAgICAgaWYgKGsgaW4gTyAmJiBPW2tdID09PSBzZWFyY2hFbGVtZW50KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBrKys7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG5cXG5cXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgLy8gVGVtcGxhdGVcXG5cXG4gICAgdmFyIGJhc2VfaHRtbCA9XFxuICAgICAgICAnPHNwYW4gY2xhc3M9XFxcImlyc1xcXCI+JyArXFxuICAgICAgICAnPHNwYW4gY2xhc3M9XFxcImlycy1saW5lXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+PC9zcGFuPicgK1xcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJpcnMtbWluXFxcIj4wPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJpcnMtbWF4XFxcIj4xPC9zcGFuPicgK1xcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJpcnMtZnJvbVxcXCI+MDwvc3Bhbj48c3BhbiBjbGFzcz1cXFwiaXJzLXRvXFxcIj4wPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJpcnMtc2luZ2xlXFxcIj4wPC9zcGFuPicgK1xcbiAgICAgICAgJzwvc3Bhbj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwiaXJzLWdyaWRcXFwiPjwvc3Bhbj4nO1xcblxcbiAgICB2YXIgc2luZ2xlX2h0bWwgPVxcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJpcnMtYmFyIGlycy1iYXItLXNpbmdsZVxcXCI+PC9zcGFuPicgK1xcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJpcnMtc2hhZG93IHNoYWRvdy1zaW5nbGVcXFwiPjwvc3Bhbj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwiaXJzLWhhbmRsZSBzaW5nbGVcXFwiPjxpPjwvaT48aT48L2k+PGk+PC9pPjwvc3Bhbj4nO1xcblxcbiAgICB2YXIgZG91YmxlX2h0bWwgPVxcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJpcnMtYmFyXFxcIj48L3NwYW4+JyArXFxuICAgICAgICAnPHNwYW4gY2xhc3M9XFxcImlycy1zaGFkb3cgc2hhZG93LWZyb21cXFwiPjwvc3Bhbj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwiaXJzLXNoYWRvdyBzaGFkb3ctdG9cXFwiPjwvc3Bhbj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwiaXJzLWhhbmRsZSBmcm9tXFxcIj48aT48L2k+PGk+PC9pPjxpPjwvaT48L3NwYW4+JyArXFxuICAgICAgICAnPHNwYW4gY2xhc3M9XFxcImlycy1oYW5kbGUgdG9cXFwiPjxpPjwvaT48aT48L2k+PGk+PC9pPjwvc3Bhbj4nO1xcblxcbiAgICB2YXIgZGlzYWJsZV9odG1sID1cXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwiaXJzLWRpc2FibGUtbWFza1xcXCI+PC9zcGFuPic7XFxuXFxuXFxuXFxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIC8vIENvcmVcXG5cXG4gICAgLyoqXFxuICAgICAqIE1haW4gcGx1Z2luIGNvbnN0cnVjdG9yXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBpbnB1dCB7T2JqZWN0fSBsaW5rIHRvIGJhc2UgaW5wdXQgZWxlbWVudFxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBzbGlkZXIgY29uZmlnXFxuICAgICAqIEBwYXJhbSBwbHVnaW5fY291bnQge051bWJlcn1cXG4gICAgICogQGNvbnN0cnVjdG9yXFxuICAgICAqL1xcbiAgICB2YXIgSW9uUmFuZ2VTbGlkZXIgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMsIHBsdWdpbl9jb3VudCkge1xcbiAgICAgICAgdGhpcy5WRVJTSU9OID0gXFxcIjIuMy4xXFxcIjtcXG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcXG4gICAgICAgIHRoaXMucGx1Z2luX2NvdW50ID0gcGx1Z2luX2NvdW50O1xcbiAgICAgICAgdGhpcy5jdXJyZW50X3BsdWdpbiA9IDA7XFxuICAgICAgICB0aGlzLmNhbGNfY291bnQgPSAwO1xcbiAgICAgICAgdGhpcy51cGRhdGVfdG0gPSAwO1xcbiAgICAgICAgdGhpcy5vbGRfZnJvbSA9IDA7XFxuICAgICAgICB0aGlzLm9sZF90byA9IDA7XFxuICAgICAgICB0aGlzLm9sZF9taW5faW50ZXJ2YWwgPSBudWxsO1xcbiAgICAgICAgdGhpcy5yYWZfaWQgPSBudWxsO1xcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5mb3JjZV9yZWRyYXcgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMubm9fZGlhcGFzb24gPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuaGFzX3RhYl9pbmRleCA9IHRydWU7XFxuICAgICAgICB0aGlzLmlzX2tleSA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5pc191cGRhdGUgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuaXNfc3RhcnQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5pc19maW5pc2ggPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuaXNfYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICB0aGlzLmlzX3Jlc2l6ZSA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5pc19jbGljayA9IGZhbHNlO1xcblxcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgICAgICAvLyBjYWNoZSBmb3IgbGlua3MgdG8gYWxsIERPTSBlbGVtZW50c1xcbiAgICAgICAgdGhpcy4kY2FjaGUgPSB7XFxuICAgICAgICAgICAgd2luOiAkKHdpbmRvdyksXFxuICAgICAgICAgICAgYm9keTogJChkb2N1bWVudC5ib2R5KSxcXG4gICAgICAgICAgICBpbnB1dDogJChpbnB1dCksXFxuICAgICAgICAgICAgY29udDogbnVsbCxcXG4gICAgICAgICAgICByczogbnVsbCxcXG4gICAgICAgICAgICBtaW46IG51bGwsXFxuICAgICAgICAgICAgbWF4OiBudWxsLFxcbiAgICAgICAgICAgIGZyb206IG51bGwsXFxuICAgICAgICAgICAgdG86IG51bGwsXFxuICAgICAgICAgICAgc2luZ2xlOiBudWxsLFxcbiAgICAgICAgICAgIGJhcjogbnVsbCxcXG4gICAgICAgICAgICBsaW5lOiBudWxsLFxcbiAgICAgICAgICAgIHNfc2luZ2xlOiBudWxsLFxcbiAgICAgICAgICAgIHNfZnJvbTogbnVsbCxcXG4gICAgICAgICAgICBzX3RvOiBudWxsLFxcbiAgICAgICAgICAgIHNoYWRfc2luZ2xlOiBudWxsLFxcbiAgICAgICAgICAgIHNoYWRfZnJvbTogbnVsbCxcXG4gICAgICAgICAgICBzaGFkX3RvOiBudWxsLFxcbiAgICAgICAgICAgIGVkZ2U6IG51bGwsXFxuICAgICAgICAgICAgZ3JpZDogbnVsbCxcXG4gICAgICAgICAgICBncmlkX2xhYmVsczogW11cXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBzdG9yYWdlIGZvciBtZWFzdXJlIHZhcmlhYmxlc1xcbiAgICAgICAgdGhpcy5jb29yZHMgPSB7XFxuICAgICAgICAgICAgLy8gbGVmdFxcbiAgICAgICAgICAgIHhfZ2FwOiAwLFxcbiAgICAgICAgICAgIHhfcG9pbnRlcjogMCxcXG5cXG4gICAgICAgICAgICAvLyB3aWR0aFxcbiAgICAgICAgICAgIHdfcnM6IDAsXFxuICAgICAgICAgICAgd19yc19vbGQ6IDAsXFxuICAgICAgICAgICAgd19oYW5kbGU6IDAsXFxuXFxuICAgICAgICAgICAgLy8gcGVyY2VudHNcXG4gICAgICAgICAgICBwX2dhcDogMCxcXG4gICAgICAgICAgICBwX2dhcF9sZWZ0OiAwLFxcbiAgICAgICAgICAgIHBfZ2FwX3JpZ2h0OiAwLFxcbiAgICAgICAgICAgIHBfc3RlcDogMCxcXG4gICAgICAgICAgICBwX3BvaW50ZXI6IDAsXFxuICAgICAgICAgICAgcF9oYW5kbGU6IDAsXFxuICAgICAgICAgICAgcF9zaW5nbGVfZmFrZTogMCxcXG4gICAgICAgICAgICBwX3NpbmdsZV9yZWFsOiAwLFxcbiAgICAgICAgICAgIHBfZnJvbV9mYWtlOiAwLFxcbiAgICAgICAgICAgIHBfZnJvbV9yZWFsOiAwLFxcbiAgICAgICAgICAgIHBfdG9fZmFrZTogMCxcXG4gICAgICAgICAgICBwX3RvX3JlYWw6IDAsXFxuICAgICAgICAgICAgcF9iYXJfeDogMCxcXG4gICAgICAgICAgICBwX2Jhcl93OiAwLFxcblxcbiAgICAgICAgICAgIC8vIGdyaWRcXG4gICAgICAgICAgICBncmlkX2dhcDogMCxcXG4gICAgICAgICAgICBiaWdfbnVtOiAwLFxcbiAgICAgICAgICAgIGJpZzogW10sXFxuICAgICAgICAgICAgYmlnX3c6IFtdLFxcbiAgICAgICAgICAgIGJpZ19wOiBbXSxcXG4gICAgICAgICAgICBiaWdfeDogW11cXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBzdG9yYWdlIGZvciBsYWJlbHMgbWVhc3VyZSB2YXJpYWJsZXNcXG4gICAgICAgIHRoaXMubGFiZWxzID0ge1xcbiAgICAgICAgICAgIC8vIHdpZHRoXFxuICAgICAgICAgICAgd19taW46IDAsXFxuICAgICAgICAgICAgd19tYXg6IDAsXFxuICAgICAgICAgICAgd19mcm9tOiAwLFxcbiAgICAgICAgICAgIHdfdG86IDAsXFxuICAgICAgICAgICAgd19zaW5nbGU6IDAsXFxuXFxuICAgICAgICAgICAgLy8gcGVyY2VudHNcXG4gICAgICAgICAgICBwX21pbjogMCxcXG4gICAgICAgICAgICBwX21heDogMCxcXG4gICAgICAgICAgICBwX2Zyb21fZmFrZTogMCxcXG4gICAgICAgICAgICBwX2Zyb21fbGVmdDogMCxcXG4gICAgICAgICAgICBwX3RvX2Zha2U6IDAsXFxuICAgICAgICAgICAgcF90b19sZWZ0OiAwLFxcbiAgICAgICAgICAgIHBfc2luZ2xlX2Zha2U6IDAsXFxuICAgICAgICAgICAgcF9zaW5nbGVfbGVmdDogMFxcbiAgICAgICAgfTtcXG5cXG5cXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogZ2V0IGFuZCB2YWxpZGF0ZSBjb25maWdcXG4gICAgICAgICAqL1xcbiAgICAgICAgdmFyICRpbnAgPSB0aGlzLiRjYWNoZS5pbnB1dCxcXG4gICAgICAgICAgICB2YWwgPSAkaW5wLnByb3AoXFxcInZhbHVlXFxcIiksXFxuICAgICAgICAgICAgY29uZmlnLCBjb25maWdfZnJvbV9kYXRhLCBwcm9wO1xcblxcbiAgICAgICAgLy8gZGVmYXVsdCBjb25maWdcXG4gICAgICAgIGNvbmZpZyA9IHtcXG4gICAgICAgICAgICBza2luOiBcXFwiZmxhdFxcXCIsXFxuICAgICAgICAgICAgdHlwZTogXFxcInNpbmdsZVxcXCIsXFxuXFxuICAgICAgICAgICAgbWluOiAxMCxcXG4gICAgICAgICAgICBtYXg6IDEwMCxcXG4gICAgICAgICAgICBmcm9tOiBudWxsLFxcbiAgICAgICAgICAgIHRvOiBudWxsLFxcbiAgICAgICAgICAgIHN0ZXA6IDEsXFxuXFxuICAgICAgICAgICAgbWluX2ludGVydmFsOiAwLFxcbiAgICAgICAgICAgIG1heF9pbnRlcnZhbDogMCxcXG4gICAgICAgICAgICBkcmFnX2ludGVydmFsOiBmYWxzZSxcXG5cXG4gICAgICAgICAgICB2YWx1ZXM6IFtdLFxcbiAgICAgICAgICAgIHBfdmFsdWVzOiBbXSxcXG5cXG4gICAgICAgICAgICBmcm9tX2ZpeGVkOiBmYWxzZSxcXG4gICAgICAgICAgICBmcm9tX21pbjogbnVsbCxcXG4gICAgICAgICAgICBmcm9tX21heDogbnVsbCxcXG4gICAgICAgICAgICBmcm9tX3NoYWRvdzogZmFsc2UsXFxuXFxuICAgICAgICAgICAgdG9fZml4ZWQ6IGZhbHNlLFxcbiAgICAgICAgICAgIHRvX21pbjogbnVsbCxcXG4gICAgICAgICAgICB0b19tYXg6IG51bGwsXFxuICAgICAgICAgICAgdG9fc2hhZG93OiBmYWxzZSxcXG5cXG4gICAgICAgICAgICBwcmV0dGlmeV9lbmFibGVkOiB0cnVlLFxcbiAgICAgICAgICAgIHByZXR0aWZ5X3NlcGFyYXRvcjogXFxcIiBcXFwiLFxcbiAgICAgICAgICAgIHByZXR0aWZ5OiBudWxsLFxcblxcbiAgICAgICAgICAgIGZvcmNlX2VkZ2VzOiBmYWxzZSxcXG5cXG4gICAgICAgICAgICBrZXlib2FyZDogdHJ1ZSxcXG5cXG4gICAgICAgICAgICBncmlkOiBmYWxzZSxcXG4gICAgICAgICAgICBncmlkX21hcmdpbjogdHJ1ZSxcXG4gICAgICAgICAgICBncmlkX251bTogNCxcXG4gICAgICAgICAgICBncmlkX3NuYXA6IGZhbHNlLFxcblxcbiAgICAgICAgICAgIGhpZGVfbWluX21heDogZmFsc2UsXFxuICAgICAgICAgICAgaGlkZV9mcm9tX3RvOiBmYWxzZSxcXG5cXG4gICAgICAgICAgICBwcmVmaXg6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHBvc3RmaXg6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIG1heF9wb3N0Zml4OiBcXFwiXFxcIixcXG4gICAgICAgICAgICBkZWNvcmF0ZV9ib3RoOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlc19zZXBhcmF0b3I6IFxcXCIg4oCUIFxcXCIsXFxuXFxuICAgICAgICAgICAgaW5wdXRfdmFsdWVzX3NlcGFyYXRvcjogXFxcIjtcXFwiLFxcblxcbiAgICAgICAgICAgIGRpc2FibGU6IGZhbHNlLFxcbiAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcXG5cXG4gICAgICAgICAgICBleHRyYV9jbGFzc2VzOiBcXFwiXFxcIixcXG5cXG4gICAgICAgICAgICBzY29wZTogbnVsbCxcXG4gICAgICAgICAgICBvblN0YXJ0OiBudWxsLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBudWxsLFxcbiAgICAgICAgICAgIG9uRmluaXNoOiBudWxsLFxcbiAgICAgICAgICAgIG9uVXBkYXRlOiBudWxsXFxuICAgICAgICB9O1xcblxcblxcbiAgICAgICAgLy8gY2hlY2sgaWYgYmFzZSBlbGVtZW50IGlzIGlucHV0XFxuICAgICAgICBpZiAoJGlucFswXS5ub2RlTmFtZSAhPT0gXFxcIklOUFVUXFxcIikge1xcbiAgICAgICAgICAgIGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUud2FybihcXFwiQmFzZSBlbGVtZW50IHNob3VsZCBiZSA8aW5wdXQ+IVxcXCIsICRpbnBbMF0pO1xcbiAgICAgICAgfVxcblxcblxcbiAgICAgICAgLy8gY29uZmlnIGZyb20gZGF0YS1hdHRyaWJ1dGVzIGV4dGVuZHMganMgY29uZmlnXFxuICAgICAgICBjb25maWdfZnJvbV9kYXRhID0ge1xcbiAgICAgICAgICAgIHNraW46ICRpbnAuZGF0YShcXFwic2tpblxcXCIpLFxcbiAgICAgICAgICAgIHR5cGU6ICRpbnAuZGF0YShcXFwidHlwZVxcXCIpLFxcblxcbiAgICAgICAgICAgIG1pbjogJGlucC5kYXRhKFxcXCJtaW5cXFwiKSxcXG4gICAgICAgICAgICBtYXg6ICRpbnAuZGF0YShcXFwibWF4XFxcIiksXFxuICAgICAgICAgICAgZnJvbTogJGlucC5kYXRhKFxcXCJmcm9tXFxcIiksXFxuICAgICAgICAgICAgdG86ICRpbnAuZGF0YShcXFwidG9cXFwiKSxcXG4gICAgICAgICAgICBzdGVwOiAkaW5wLmRhdGEoXFxcInN0ZXBcXFwiKSxcXG5cXG4gICAgICAgICAgICBtaW5faW50ZXJ2YWw6ICRpbnAuZGF0YShcXFwibWluSW50ZXJ2YWxcXFwiKSxcXG4gICAgICAgICAgICBtYXhfaW50ZXJ2YWw6ICRpbnAuZGF0YShcXFwibWF4SW50ZXJ2YWxcXFwiKSxcXG4gICAgICAgICAgICBkcmFnX2ludGVydmFsOiAkaW5wLmRhdGEoXFxcImRyYWdJbnRlcnZhbFxcXCIpLFxcblxcbiAgICAgICAgICAgIHZhbHVlczogJGlucC5kYXRhKFxcXCJ2YWx1ZXNcXFwiKSxcXG5cXG4gICAgICAgICAgICBmcm9tX2ZpeGVkOiAkaW5wLmRhdGEoXFxcImZyb21GaXhlZFxcXCIpLFxcbiAgICAgICAgICAgIGZyb21fbWluOiAkaW5wLmRhdGEoXFxcImZyb21NaW5cXFwiKSxcXG4gICAgICAgICAgICBmcm9tX21heDogJGlucC5kYXRhKFxcXCJmcm9tTWF4XFxcIiksXFxuICAgICAgICAgICAgZnJvbV9zaGFkb3c6ICRpbnAuZGF0YShcXFwiZnJvbVNoYWRvd1xcXCIpLFxcblxcbiAgICAgICAgICAgIHRvX2ZpeGVkOiAkaW5wLmRhdGEoXFxcInRvRml4ZWRcXFwiKSxcXG4gICAgICAgICAgICB0b19taW46ICRpbnAuZGF0YShcXFwidG9NaW5cXFwiKSxcXG4gICAgICAgICAgICB0b19tYXg6ICRpbnAuZGF0YShcXFwidG9NYXhcXFwiKSxcXG4gICAgICAgICAgICB0b19zaGFkb3c6ICRpbnAuZGF0YShcXFwidG9TaGFkb3dcXFwiKSxcXG5cXG4gICAgICAgICAgICBwcmV0dGlmeV9lbmFibGVkOiAkaW5wLmRhdGEoXFxcInByZXR0aWZ5RW5hYmxlZFxcXCIpLFxcbiAgICAgICAgICAgIHByZXR0aWZ5X3NlcGFyYXRvcjogJGlucC5kYXRhKFxcXCJwcmV0dGlmeVNlcGFyYXRvclxcXCIpLFxcblxcbiAgICAgICAgICAgIGZvcmNlX2VkZ2VzOiAkaW5wLmRhdGEoXFxcImZvcmNlRWRnZXNcXFwiKSxcXG5cXG4gICAgICAgICAgICBrZXlib2FyZDogJGlucC5kYXRhKFxcXCJrZXlib2FyZFxcXCIpLFxcblxcbiAgICAgICAgICAgIGdyaWQ6ICRpbnAuZGF0YShcXFwiZ3JpZFxcXCIpLFxcbiAgICAgICAgICAgIGdyaWRfbWFyZ2luOiAkaW5wLmRhdGEoXFxcImdyaWRNYXJnaW5cXFwiKSxcXG4gICAgICAgICAgICBncmlkX251bTogJGlucC5kYXRhKFxcXCJncmlkTnVtXFxcIiksXFxuICAgICAgICAgICAgZ3JpZF9zbmFwOiAkaW5wLmRhdGEoXFxcImdyaWRTbmFwXFxcIiksXFxuXFxuICAgICAgICAgICAgaGlkZV9taW5fbWF4OiAkaW5wLmRhdGEoXFxcImhpZGVNaW5NYXhcXFwiKSxcXG4gICAgICAgICAgICBoaWRlX2Zyb21fdG86ICRpbnAuZGF0YShcXFwiaGlkZUZyb21Ub1xcXCIpLFxcblxcbiAgICAgICAgICAgIHByZWZpeDogJGlucC5kYXRhKFxcXCJwcmVmaXhcXFwiKSxcXG4gICAgICAgICAgICBwb3N0Zml4OiAkaW5wLmRhdGEoXFxcInBvc3RmaXhcXFwiKSxcXG4gICAgICAgICAgICBtYXhfcG9zdGZpeDogJGlucC5kYXRhKFxcXCJtYXhQb3N0Zml4XFxcIiksXFxuICAgICAgICAgICAgZGVjb3JhdGVfYm90aDogJGlucC5kYXRhKFxcXCJkZWNvcmF0ZUJvdGhcXFwiKSxcXG4gICAgICAgICAgICB2YWx1ZXNfc2VwYXJhdG9yOiAkaW5wLmRhdGEoXFxcInZhbHVlc1NlcGFyYXRvclxcXCIpLFxcblxcbiAgICAgICAgICAgIGlucHV0X3ZhbHVlc19zZXBhcmF0b3I6ICRpbnAuZGF0YShcXFwiaW5wdXRWYWx1ZXNTZXBhcmF0b3JcXFwiKSxcXG5cXG4gICAgICAgICAgICBkaXNhYmxlOiAkaW5wLmRhdGEoXFxcImRpc2FibGVcXFwiKSxcXG4gICAgICAgICAgICBibG9jazogJGlucC5kYXRhKFxcXCJibG9ja1xcXCIpLFxcblxcbiAgICAgICAgICAgIGV4dHJhX2NsYXNzZXM6ICRpbnAuZGF0YShcXFwiZXh0cmFDbGFzc2VzXFxcIiksXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uZmlnX2Zyb21fZGF0YS52YWx1ZXMgPSBjb25maWdfZnJvbV9kYXRhLnZhbHVlcyAmJiBjb25maWdfZnJvbV9kYXRhLnZhbHVlcy5zcGxpdChcXFwiLFxcXCIpO1xcblxcbiAgICAgICAgZm9yIChwcm9wIGluIGNvbmZpZ19mcm9tX2RhdGEpIHtcXG4gICAgICAgICAgICBpZiAoY29uZmlnX2Zyb21fZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnX2Zyb21fZGF0YVtwcm9wXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZ19mcm9tX2RhdGFbcHJvcF0gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnX2Zyb21fZGF0YVtwcm9wXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG5cXG4gICAgICAgIC8vIGlucHV0IHZhbHVlIGV4dGVuZHMgZGVmYXVsdCBjb25maWdcXG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgdmFsID0gdmFsLnNwbGl0KGNvbmZpZ19mcm9tX2RhdGEuaW5wdXRfdmFsdWVzX3NlcGFyYXRvciB8fCBvcHRpb25zLmlucHV0X3ZhbHVlc19zZXBhcmF0b3IgfHwgXFxcIjtcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAodmFsWzBdICYmIHZhbFswXSA9PSArdmFsWzBdKSB7XFxuICAgICAgICAgICAgICAgIHZhbFswXSA9ICt2YWxbMF07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh2YWxbMV0gJiYgdmFsWzFdID09ICt2YWxbMV0pIHtcXG4gICAgICAgICAgICAgICAgdmFsWzFdID0gK3ZhbFsxXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy52YWx1ZXMgJiYgb3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIGNvbmZpZy5mcm9tID0gdmFsWzBdICYmIG9wdGlvbnMudmFsdWVzLmluZGV4T2YodmFsWzBdKTtcXG4gICAgICAgICAgICAgICAgY29uZmlnLnRvID0gdmFsWzFdICYmIG9wdGlvbnMudmFsdWVzLmluZGV4T2YodmFsWzFdKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjb25maWcuZnJvbSA9IHZhbFswXSAmJiArdmFsWzBdO1xcbiAgICAgICAgICAgICAgICBjb25maWcudG8gPSB2YWxbMV0gJiYgK3ZhbFsxXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuXFxuXFxuICAgICAgICAvLyBqcyBjb25maWcgZXh0ZW5kcyBkZWZhdWx0IGNvbmZpZ1xcbiAgICAgICAgJC5leHRlbmQoY29uZmlnLCBvcHRpb25zKTtcXG5cXG5cXG4gICAgICAgIC8vIGRhdGEgY29uZmlnIGV4dGVuZHMgY29uZmlnXFxuICAgICAgICAkLmV4dGVuZChjb25maWcsIGNvbmZpZ19mcm9tX2RhdGEpO1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnO1xcblxcblxcblxcbiAgICAgICAgLy8gdmFsaWRhdGUgY29uZmlnLCB0byBiZSBzdXJlIHRoYXQgYWxsIGRhdGEgdHlwZXMgYXJlIGNvcnJlY3RcXG4gICAgICAgIHRoaXMudXBkYXRlX2NoZWNrID0ge307XFxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XFxuXFxuXFxuXFxuICAgICAgICAvLyBkZWZhdWx0IHJlc3VsdCBvYmplY3QsIHJldHVybmVkIHRvIGNhbGxiYWNrc1xcbiAgICAgICAgdGhpcy5yZXN1bHQgPSB7XFxuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuJGNhY2hlLmlucHV0LFxcbiAgICAgICAgICAgIHNsaWRlcjogbnVsbCxcXG5cXG4gICAgICAgICAgICBtaW46IHRoaXMub3B0aW9ucy5taW4sXFxuICAgICAgICAgICAgbWF4OiB0aGlzLm9wdGlvbnMubWF4LFxcblxcbiAgICAgICAgICAgIGZyb206IHRoaXMub3B0aW9ucy5mcm9tLFxcbiAgICAgICAgICAgIGZyb21fcGVyY2VudDogMCxcXG4gICAgICAgICAgICBmcm9tX3ZhbHVlOiBudWxsLFxcblxcbiAgICAgICAgICAgIHRvOiB0aGlzLm9wdGlvbnMudG8sXFxuICAgICAgICAgICAgdG9fcGVyY2VudDogMCxcXG4gICAgICAgICAgICB0b192YWx1ZTogbnVsbFxcbiAgICAgICAgfTtcXG5cXG5cXG5cXG4gICAgICAgIHRoaXMuaW5pdCgpO1xcbiAgICB9O1xcblxcbiAgICBJb25SYW5nZVNsaWRlci5wcm90b3R5cGUgPSB7XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFN0YXJ0cyBvciB1cGRhdGVzIHRoZSBwbHVnaW4gaW5zdGFuY2VcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gW2lzX3VwZGF0ZV0ge2Jvb2xlYW59XFxuICAgICAgICAgKi9cXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChpc191cGRhdGUpIHtcXG4gICAgICAgICAgICB0aGlzLm5vX2RpYXBhc29uID0gZmFsc2U7XFxuICAgICAgICAgICAgdGhpcy5jb29yZHMucF9zdGVwID0gdGhpcy5jb252ZXJ0VG9QZXJjZW50KHRoaXMub3B0aW9ucy5zdGVwLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IFxcXCJiYXNlXFxcIjtcXG5cXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUlucHV0KCk7XFxuICAgICAgICAgICAgdGhpcy5hcHBlbmQoKTtcXG4gICAgICAgICAgICB0aGlzLnNldE1pbk1heCgpO1xcblxcbiAgICAgICAgICAgIGlmIChpc191cGRhdGUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZV9yZWRyYXcgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGModHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrcyBjYWxsZWRcXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsT25VcGRhdGUoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlX3JlZHJhdyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyh0cnVlKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tzIGNhbGxlZFxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxPblN0YXJ0KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2NlbmUoKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEFwcGVuZHMgc2xpZGVyIHRlbXBsYXRlIHRvIGEgRE9NXFxuICAgICAgICAgKi9cXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBjb250YWluZXJfaHRtbCA9ICc8c3BhbiBjbGFzcz1cXFwiaXJzIGlycy0tJyArIHRoaXMub3B0aW9ucy5za2luICsgJyBqcy1pcnMtJyArIHRoaXMucGx1Z2luX2NvdW50ICsgJyAnICsgdGhpcy5vcHRpb25zLmV4dHJhX2NsYXNzZXMgKyAnXFxcIj48L3NwYW4+JztcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5pbnB1dC5iZWZvcmUoY29udGFpbmVyX2h0bWwpO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LnByb3AoXFxcInJlYWRvbmx5XFxcIiwgdHJ1ZSk7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuY29udCA9IHRoaXMuJGNhY2hlLmlucHV0LnByZXYoKTtcXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5zbGlkZXIgPSB0aGlzLiRjYWNoZS5jb250O1xcblxcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmNvbnQuaHRtbChiYXNlX2h0bWwpO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLnJzID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzXFxcIik7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUubWluID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLW1pblxcXCIpO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1heCA9IHRoaXMuJGNhY2hlLmNvbnQuZmluZChcXFwiLmlycy1tYXhcXFwiKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLWZyb21cXFwiKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS50byA9IHRoaXMuJGNhY2hlLmNvbnQuZmluZChcXFwiLmlycy10b1xcXCIpO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNpbmdsZSA9IHRoaXMuJGNhY2hlLmNvbnQuZmluZChcXFwiLmlycy1zaW5nbGVcXFwiKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5saW5lID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLWxpbmVcXFwiKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5ncmlkID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLWdyaWRcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmNvbnQuYXBwZW5kKHNpbmdsZV9odG1sKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuYmFyID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLWJhclxcXCIpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5lZGdlID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLWJhci1lZGdlXFxcIik7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfc2luZ2xlID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuc2luZ2xlXFxcIik7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmZyb21bMF0uc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS50b1swXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcImhpZGRlblxcXCI7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNoYWRfc2luZ2xlID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuc2hhZG93LXNpbmdsZVxcXCIpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmNvbnQuYXBwZW5kKGRvdWJsZV9odG1sKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuYmFyID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuaXJzLWJhclxcXCIpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zX2Zyb20gPSB0aGlzLiRjYWNoZS5jb250LmZpbmQoXFxcIi5mcm9tXFxcIik7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfdG8gPSB0aGlzLiRjYWNoZS5jb250LmZpbmQoXFxcIi50b1xcXCIpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaGFkX2Zyb20gPSB0aGlzLiRjYWNoZS5jb250LmZpbmQoXFxcIi5zaGFkb3ctZnJvbVxcXCIpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaGFkX3RvID0gdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuc2hhZG93LXRvXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9wSGFuZGxlcigpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZGVfZnJvbV90bykge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tWzBdLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnRvWzBdLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNpbmdsZVswXS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLmFwcGVuZEdyaWQoKTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmREaXNhYmxlTWFzaygpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5pbnB1dFswXS5kaXNhYmxlZCA9IHRydWU7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuaW5wdXRbMF0uZGlzYWJsZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEaXNhYmxlTWFzaygpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gYmxvY2sgb25seSBpZiBub3QgZGlzYWJsZWRcXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2spIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRGlzYWJsZU1hc2soKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGlzYWJsZU1hc2soKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdfaW50ZXJ2YWwpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuYmFyWzBdLnN0eWxlLmN1cnNvciA9IFxcXCJldy1yZXNpemVcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIERldGVybWluZSB3aGljaCBoYW5kbGVyIGhhcyBhIHByaW9yaXR5XFxuICAgICAgICAgKiB3b3JrcyBvbmx5IGZvciBkb3VibGUgc2xpZGVyIHR5cGVcXG4gICAgICAgICAqL1xcbiAgICAgICAgc2V0VG9wSGFuZGxlcjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBtaW4gPSB0aGlzLm9wdGlvbnMubWluLFxcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLm9wdGlvbnMubWF4LFxcbiAgICAgICAgICAgICAgICBmcm9tID0gdGhpcy5vcHRpb25zLmZyb20sXFxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5vcHRpb25zLnRvO1xcblxcbiAgICAgICAgICAgIGlmIChmcm9tID4gbWluICYmIHRvID09PSBtYXgpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc19mcm9tLmFkZENsYXNzKFxcXCJ0eXBlX2xhc3RcXFwiKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvIDwgbWF4KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfdG8uYWRkQ2xhc3MoXFxcInR5cGVfbGFzdFxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIERldGVybWluZSB3aGljaCBoYW5kbGVzIHdhcyBjbGlja2VkIGxhc3RcXG4gICAgICAgICAqIGFuZCB3aGljaCBoYW5kbGVyIHNob3VsZCBoYXZlIGhvdmVyIGVmZmVjdFxcbiAgICAgICAgICpcXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQge1N0cmluZ31cXG4gICAgICAgICAqL1xcbiAgICAgICAgY2hhbmdlTGV2ZWw6IGZ1bmN0aW9uICh0YXJnZXQpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKHRhcmdldCkge1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJzaW5nbGVcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9nYXAgPSB0aGlzLnRvRml4ZWQodGhpcy5jb29yZHMucF9wb2ludGVyIC0gdGhpcy5jb29yZHMucF9zaW5nbGVfZmFrZSk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zX3NpbmdsZS5hZGRDbGFzcyhcXFwic3RhdGVfaG92ZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJmcm9tXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZ2FwID0gdGhpcy50b0ZpeGVkKHRoaXMuY29vcmRzLnBfcG9pbnRlciAtIHRoaXMuY29vcmRzLnBfZnJvbV9mYWtlKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfZnJvbS5hZGRDbGFzcyhcXFwic3RhdGVfaG92ZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfZnJvbS5hZGRDbGFzcyhcXFwidHlwZV9sYXN0XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zX3RvLnJlbW92ZUNsYXNzKFxcXCJ0eXBlX2xhc3RcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJ0b1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2dhcCA9IHRoaXMudG9GaXhlZCh0aGlzLmNvb3Jkcy5wX3BvaW50ZXIgLSB0aGlzLmNvb3Jkcy5wX3RvX2Zha2UpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc190by5hZGRDbGFzcyhcXFwic3RhdGVfaG92ZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfdG8uYWRkQ2xhc3MoXFxcInR5cGVfbGFzdFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc19mcm9tLnJlbW92ZUNsYXNzKFxcXCJ0eXBlX2xhc3RcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJib3RoXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZ2FwX2xlZnQgPSB0aGlzLnRvRml4ZWQodGhpcy5jb29yZHMucF9wb2ludGVyIC0gdGhpcy5jb29yZHMucF9mcm9tX2Zha2UpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9nYXBfcmlnaHQgPSB0aGlzLnRvRml4ZWQodGhpcy5jb29yZHMucF90b19mYWtlIC0gdGhpcy5jb29yZHMucF9wb2ludGVyKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfdG8ucmVtb3ZlQ2xhc3MoXFxcInR5cGVfbGFzdFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc19mcm9tLnJlbW92ZUNsYXNzKFxcXCJ0eXBlX2xhc3RcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFRoZW4gc2xpZGVyIGlzIGRpc2FibGVkXFxuICAgICAgICAgKiBhcHBlbmRzIGV4dHJhIGxheWVyIHdpdGggb3BhY2l0eVxcbiAgICAgICAgICovXFxuICAgICAgICBhcHBlbmREaXNhYmxlTWFzazogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmNvbnQuYXBwZW5kKGRpc2FibGVfaHRtbCk7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuY29udC5hZGRDbGFzcyhcXFwiaXJzLWRpc2FibGVkXFxcIik7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBUaGVuIHNsaWRlciBpcyBub3QgZGlzYWJsZWRcXG4gICAgICAgICAqIHJlbW92ZSBkaXNhYmxlIG1hc2tcXG4gICAgICAgICAqL1xcbiAgICAgICAgcmVtb3ZlRGlzYWJsZU1hc2s6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5jb250LnJlbW92ZShcXFwiLmlycy1kaXNhYmxlLW1hc2tcXFwiKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5jb250LnJlbW92ZUNsYXNzKFxcXCJpcnMtZGlzYWJsZWRcXFwiKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFJlbW92ZSBzbGlkZXIgaW5zdGFuY2VcXG4gICAgICAgICAqIGFuZCB1bmJpbmQgYWxsIGV2ZW50c1xcbiAgICAgICAgICovXFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5jb250LnJlbW92ZSgpO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmNvbnQgPSBudWxsO1xcblxcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmxpbmUub2ZmKFxcXCJrZXlkb3duLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQpO1xcblxcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmJvZHkub2ZmKFxcXCJ0b3VjaG1vdmUuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCk7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuYm9keS5vZmYoXFxcIm1vdXNlbW92ZS5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50KTtcXG5cXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS53aW4ub2ZmKFxcXCJ0b3VjaGVuZC5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50KTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS53aW4ub2ZmKFxcXCJtb3VzZXVwLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQpO1xcblxcbiAgICAgICAgICAgIGlmIChpc19vbGRfaWUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuYm9keS5vZmYoXFxcIm1vdXNldXAuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmJvZHkub2ZmKFxcXCJtb3VzZWxlYXZlLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5ncmlkX2xhYmVscyA9IFtdO1xcbiAgICAgICAgICAgIHRoaXMuY29vcmRzLmJpZyA9IFtdO1xcbiAgICAgICAgICAgIHRoaXMuY29vcmRzLmJpZ193ID0gW107XFxuICAgICAgICAgICAgdGhpcy5jb29yZHMuYmlnX3AgPSBbXTtcXG4gICAgICAgICAgICB0aGlzLmNvb3Jkcy5iaWdfeCA9IFtdO1xcblxcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmX2lkKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIGJpbmQgYWxsIHNsaWRlciBldmVudHNcXG4gICAgICAgICAqL1xcbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLm5vX2RpYXBhc29uKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuYm9keS5vbihcXFwidG91Y2htb3ZlLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuYm9keS5vbihcXFwibW91c2Vtb3ZlLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XFxuXFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUud2luLm9uKFxcXCJ0b3VjaGVuZC5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS53aW4ub24oXFxcIm1vdXNldXAuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XFxuXFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUubGluZS5vbihcXFwidG91Y2hzdGFydC5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJDbGljay5iaW5kKHRoaXMsIFxcXCJjbGlja1xcXCIpKTtcXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5saW5lLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyQ2xpY2suYmluZCh0aGlzLCBcXFwiY2xpY2tcXFwiKSk7XFxuXFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUubGluZS5vbihcXFwiZm9jdXMuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRm9jdXMuYmluZCh0aGlzKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnX2ludGVydmFsICYmIHRoaXMub3B0aW9ucy50eXBlID09PSBcXFwiZG91YmxlXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5iYXIub24oXFxcInRvdWNoc3RhcnQuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJib3RoXFxcIikpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5iYXIub24oXFxcIm1vdXNlZG93bi5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJEb3duLmJpbmQodGhpcywgXFxcImJvdGhcXFwiKSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuYmFyLm9uKFxcXCJ0b3VjaHN0YXJ0Lmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckNsaWNrLmJpbmQodGhpcywgXFxcImNsaWNrXFxcIikpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5iYXIub24oXFxcIm1vdXNlZG93bi5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJDbGljay5iaW5kKHRoaXMsIFxcXCJjbGlja1xcXCIpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBcXFwic2luZ2xlXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaW5nbGUub24oXFxcInRvdWNoc3RhcnQuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJzaW5nbGVcXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfc2luZ2xlLm9uKFxcXCJ0b3VjaHN0YXJ0Lmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckRvd24uYmluZCh0aGlzLCBcXFwic2luZ2xlXFxcIikpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaGFkX3NpbmdsZS5vbihcXFwidG91Y2hzdGFydC5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJDbGljay5iaW5kKHRoaXMsIFxcXCJjbGlja1xcXCIpKTtcXG5cXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJzaW5nbGVcXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfc2luZ2xlLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJzaW5nbGVcXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmVkZ2Uub24oXFxcIm1vdXNlZG93bi5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJDbGljay5iaW5kKHRoaXMsIFxcXCJjbGlja1xcXCIpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2hhZF9zaW5nbGUub24oXFxcIm1vdXNlZG93bi5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJDbGljay5iaW5kKHRoaXMsIFxcXCJjbGlja1xcXCIpKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaW5nbGUub24oXFxcInRvdWNoc3RhcnQuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIG51bGwpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIG51bGwpKTtcXG5cXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuZnJvbS5vbihcXFwidG91Y2hzdGFydC5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJEb3duLmJpbmQodGhpcywgXFxcImZyb21cXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfZnJvbS5vbihcXFwidG91Y2hzdGFydC5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJEb3duLmJpbmQodGhpcywgXFxcImZyb21cXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnRvLm9uKFxcXCJ0b3VjaHN0YXJ0Lmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckRvd24uYmluZCh0aGlzLCBcXFwidG9cXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNfdG8ub24oXFxcInRvdWNoc3RhcnQuaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJ0b1xcXCIpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2hhZF9mcm9tLm9uKFxcXCJ0b3VjaHN0YXJ0Lmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckNsaWNrLmJpbmQodGhpcywgXFxcImNsaWNrXFxcIikpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaGFkX3RvLm9uKFxcXCJ0b3VjaHN0YXJ0Lmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckNsaWNrLmJpbmQodGhpcywgXFxcImNsaWNrXFxcIikpO1xcblxcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJmcm9tXFxcIikpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zX2Zyb20ub24oXFxcIm1vdXNlZG93bi5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLnBvaW50ZXJEb3duLmJpbmQodGhpcywgXFxcImZyb21cXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnRvLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMsIFxcXCJ0b1xcXCIpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc190by5vbihcXFwibW91c2Vkb3duLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckRvd24uYmluZCh0aGlzLCBcXFwidG9cXFwiKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNoYWRfZnJvbS5vbihcXFwibW91c2Vkb3duLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlckNsaWNrLmJpbmQodGhpcywgXFxcImNsaWNrXFxcIikpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaGFkX3RvLm9uKFxcXCJtb3VzZWRvd24uaXJzX1xcXCIgKyB0aGlzLnBsdWdpbl9jb3VudCwgdGhpcy5wb2ludGVyQ2xpY2suYmluZCh0aGlzLCBcXFwiY2xpY2tcXFwiKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUubGluZS5vbihcXFwia2V5ZG93bi5pcnNfXFxcIiArIHRoaXMucGx1Z2luX2NvdW50LCB0aGlzLmtleS5iaW5kKHRoaXMsIFxcXCJrZXlib2FyZFxcXCIpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGlzX29sZF9pZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5ib2R5Lm9uKFxcXCJtb3VzZXVwLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5ib2R5Lm9uKFxcXCJtb3VzZWxlYXZlLmlyc19cXFwiICsgdGhpcy5wbHVnaW5fY291bnQsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZvY3VzIHdpdGggdGFiSW5kZXhcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gZSB7T2JqZWN0fSBldmVudCBvYmplY3RcXG4gICAgICAgICAqL1xcbiAgICAgICAgcG9pbnRlckZvY3VzOiBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHg7XFxuICAgICAgICAgICAgICAgIHZhciAkaGFuZGxlO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAkaGFuZGxlID0gdGhpcy4kY2FjaGUuc2luZ2xlO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgJGhhbmRsZSA9IHRoaXMuJGNhY2hlLmZyb207XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeCA9ICRoYW5kbGUub2Zmc2V0KCkubGVmdDtcXG4gICAgICAgICAgICAgICAgeCArPSAoJGhhbmRsZS53aWR0aCgpIC8gMikgLSAxO1xcblxcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJDbGljayhcXFwic2luZ2xlXFxcIiwge3ByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7fSwgcGFnZVg6IHh9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBNb3VzZW1vdmUgb3IgdG91Y2htb3ZlXFxuICAgICAgICAgKiBvbmx5IGZvciBoYW5kbGVyc1xcbiAgICAgICAgICpcXG4gICAgICAgICAqIEBwYXJhbSBlIHtPYmplY3R9IGV2ZW50IG9iamVjdFxcbiAgICAgICAgICovXFxuICAgICAgICBwb2ludGVyTW92ZTogZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggfHwgZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XFxuICAgICAgICAgICAgdGhpcy5jb29yZHMueF9wb2ludGVyID0geCAtIHRoaXMuY29vcmRzLnhfZ2FwO1xcblxcbiAgICAgICAgICAgIHRoaXMuY2FsYygpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTW91c2V1cCBvciB0b3VjaGVuZFxcbiAgICAgICAgICogb25seSBmb3IgaGFuZGxlcnNcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gZSB7T2JqZWN0fSBldmVudCBvYmplY3RcXG4gICAgICAgICAqL1xcbiAgICAgICAgcG9pbnRlclVwOiBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfcGx1Z2luICE9PSB0aGlzLnBsdWdpbl9jb3VudCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX2FjdGl2ZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmlzX2FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuY29udC5maW5kKFxcXCIuc3RhdGVfaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwic3RhdGVfaG92ZXJcXFwiKTtcXG5cXG4gICAgICAgICAgICB0aGlzLmZvcmNlX3JlZHJhdyA9IHRydWU7XFxuXFxuICAgICAgICAgICAgaWYgKGlzX29sZF9pZSkge1xcbiAgICAgICAgICAgICAgICAkKFxcXCIqXFxcIikucHJvcChcXFwidW5zZWxlY3RhYmxlXFxcIiwgZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjZW5lKCk7XFxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlT3JpZ2luYWxNaW5JbnRlcnZhbCgpO1xcblxcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrcyBjYWxsXFxuICAgICAgICAgICAgaWYgKCQuY29udGFpbnModGhpcy4kY2FjaGUuY29udFswXSwgZS50YXJnZXQpIHx8IHRoaXMuZHJhZ2dpbmcpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsT25GaW5pc2goKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTW91c2Vkb3duIG9yIHRvdWNoc3RhcnRcXG4gICAgICAgICAqIG9ubHkgZm9yIGhhbmRsZXJzXFxuICAgICAgICAgKlxcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCB7U3RyaW5nfG51bGx9XFxuICAgICAgICAgKiBAcGFyYW0gZSB7T2JqZWN0fSBldmVudCBvYmplY3RcXG4gICAgICAgICAqL1xcbiAgICAgICAgcG9pbnRlckRvd246IGZ1bmN0aW9uICh0YXJnZXQsIGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIHx8IGUub3JpZ2luYWxFdmVudC50b3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMikge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IFxcXCJib3RoXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRlbXBNaW5JbnRlcnZhbCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBcXFwiZnJvbVxcXCI7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9wbHVnaW4gPSB0aGlzLnBsdWdpbl9jb3VudDtcXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcXG5cXG4gICAgICAgICAgICB0aGlzLmlzX2FjdGl2ZSA9IHRydWU7XFxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XFxuXFxuICAgICAgICAgICAgdGhpcy5jb29yZHMueF9nYXAgPSB0aGlzLiRjYWNoZS5ycy5vZmZzZXQoKS5sZWZ0O1xcbiAgICAgICAgICAgIHRoaXMuY29vcmRzLnhfcG9pbnRlciA9IHggLSB0aGlzLmNvb3Jkcy54X2dhcDtcXG5cXG4gICAgICAgICAgICB0aGlzLmNhbGNQb2ludGVyUGVyY2VudCgpO1xcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTGV2ZWwodGFyZ2V0KTtcXG5cXG4gICAgICAgICAgICBpZiAoaXNfb2xkX2llKSB7XFxuICAgICAgICAgICAgICAgICQoXFxcIipcXFwiKS5wcm9wKFxcXCJ1bnNlbGVjdGFibGVcXFwiLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUubGluZS50cmlnZ2VyKFxcXCJmb2N1c1xcXCIpO1xcblxcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2NlbmUoKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE1vdXNlZG93biBvciB0b3VjaHN0YXJ0XFxuICAgICAgICAgKiBmb3Igb3RoZXIgc2xpZGVyIGVsZW1lbnRzLCBsaWtlIGRpYXBhc29uIGxpbmVcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IHtTdHJpbmd9XFxuICAgICAgICAgKiBAcGFyYW0gZSB7T2JqZWN0fSBldmVudCBvYmplY3RcXG4gICAgICAgICAqL1xcbiAgICAgICAgcG9pbnRlckNsaWNrOiBmdW5jdGlvbiAodGFyZ2V0LCBlKSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCB8fCBlLm9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5wYWdlWDtcXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfcGx1Z2luID0gdGhpcy5wbHVnaW5fY291bnQ7XFxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XFxuXFxuICAgICAgICAgICAgdGhpcy5pc19jbGljayA9IHRydWU7XFxuICAgICAgICAgICAgdGhpcy5jb29yZHMueF9nYXAgPSB0aGlzLiRjYWNoZS5ycy5vZmZzZXQoKS5sZWZ0O1xcbiAgICAgICAgICAgIHRoaXMuY29vcmRzLnhfcG9pbnRlciA9ICsoeCAtIHRoaXMuY29vcmRzLnhfZ2FwKS50b0ZpeGVkKCk7XFxuXFxuICAgICAgICAgICAgdGhpcy5mb3JjZV9yZWRyYXcgPSB0cnVlO1xcbiAgICAgICAgICAgIHRoaXMuY2FsYygpO1xcblxcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmxpbmUudHJpZ2dlcihcXFwiZm9jdXNcXFwiKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEtleWJvcmFyZCBjb250cm9scyBmb3IgZm9jdXNlZCBzbGlkZXJcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IHtTdHJpbmd9XFxuICAgICAgICAgKiBAcGFyYW0gZSB7T2JqZWN0fSBldmVudCBvYmplY3RcXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH1cXG4gICAgICAgICAqL1xcbiAgICAgICAga2V5OiBmdW5jdGlvbiAodGFyZ2V0LCBlKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9wbHVnaW4gIT09IHRoaXMucGx1Z2luX2NvdW50IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xcbiAgICAgICAgICAgICAgICBjYXNlIDgzOiAvLyBXXFxuICAgICAgICAgICAgICAgIGNhc2UgNjU6IC8vIEFcXG4gICAgICAgICAgICAgICAgY2FzZSA0MDogLy8gRE9XTlxcbiAgICAgICAgICAgICAgICBjYXNlIDM3OiAvLyBMRUZUXFxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVCeUtleShmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSA4NzogLy8gU1xcbiAgICAgICAgICAgICAgICBjYXNlIDY4OiAvLyBEXFxuICAgICAgICAgICAgICAgIGNhc2UgMzg6IC8vIFVQXFxuICAgICAgICAgICAgICAgIGNhc2UgMzk6IC8vIFJJR0hUXFxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVCeUtleSh0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE1vdmUgYnkga2V5XFxuICAgICAgICAgKlxcbiAgICAgICAgICogQHBhcmFtIHJpZ2h0IHtib29sZWFufSBkaXJlY3Rpb24gdG8gbW92ZVxcbiAgICAgICAgICovXFxuICAgICAgICBtb3ZlQnlLZXk6IGZ1bmN0aW9uIChyaWdodCkge1xcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5jb29yZHMucF9wb2ludGVyO1xcbiAgICAgICAgICAgIHZhciBwX3N0ZXAgPSAodGhpcy5vcHRpb25zLm1heCAtIHRoaXMub3B0aW9ucy5taW4pIC8gMTAwO1xcbiAgICAgICAgICAgIHBfc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwIC8gcF9zdGVwO1xcblxcbiAgICAgICAgICAgIGlmIChyaWdodCkge1xcbiAgICAgICAgICAgICAgICBwICs9IHBfc3RlcDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwIC09IHBfc3RlcDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5jb29yZHMueF9wb2ludGVyID0gdGhpcy50b0ZpeGVkKHRoaXMuY29vcmRzLndfcnMgLyAxMDAgKiBwKTtcXG4gICAgICAgICAgICB0aGlzLmlzX2tleSA9IHRydWU7XFxuICAgICAgICAgICAgdGhpcy5jYWxjKCk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBTZXQgdmlzaWJpbGl0eSBhbmQgY29udGVudFxcbiAgICAgICAgICogb2YgTWluIGFuZCBNYXggbGFiZWxzXFxuICAgICAgICAgKi9cXG4gICAgICAgIHNldE1pbk1heDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlX21pbl9tYXgpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUubWluWzBdLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1heFswXS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5taW4uaHRtbCh0aGlzLmRlY29yYXRlKHRoaXMub3B0aW9ucy5wX3ZhbHVlc1t0aGlzLm9wdGlvbnMubWluXSkpO1xcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5tYXguaHRtbCh0aGlzLmRlY29yYXRlKHRoaXMub3B0aW9ucy5wX3ZhbHVlc1t0aGlzLm9wdGlvbnMubWF4XSkpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHZhciBtaW5fcHJldHR5ID0gdGhpcy5fcHJldHRpZnkodGhpcy5vcHRpb25zLm1pbik7XFxuICAgICAgICAgICAgICAgIHZhciBtYXhfcHJldHR5ID0gdGhpcy5fcHJldHRpZnkodGhpcy5vcHRpb25zLm1heCk7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm1pbl9wcmV0dHkgPSBtaW5fcHJldHR5O1xcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5tYXhfcHJldHR5ID0gbWF4X3ByZXR0eTtcXG5cXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUubWluLmh0bWwodGhpcy5kZWNvcmF0ZShtaW5fcHJldHR5LCB0aGlzLm9wdGlvbnMubWluKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1heC5odG1sKHRoaXMuZGVjb3JhdGUobWF4X3ByZXR0eSwgdGhpcy5vcHRpb25zLm1heCkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLmxhYmVscy53X21pbiA9IHRoaXMuJGNhY2hlLm1pbi5vdXRlcldpZHRoKGZhbHNlKTtcXG4gICAgICAgICAgICB0aGlzLmxhYmVscy53X21heCA9IHRoaXMuJGNhY2hlLm1heC5vdXRlcldpZHRoKGZhbHNlKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFRoZW4gZHJhZ2dpbmcgaW50ZXJ2YWwsIHByZXZlbnQgaW50ZXJ2YWwgY29sbGFwc2luZ1xcbiAgICAgICAgICogdXNpbmcgbWluX2ludGVydmFsIG9wdGlvblxcbiAgICAgICAgICovXFxuICAgICAgICBzZXRUZW1wTWluSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLnJlc3VsdC50byAtIHRoaXMucmVzdWx0LmZyb207XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub2xkX21pbl9pbnRlcnZhbCA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLm9sZF9taW5faW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMubWluX2ludGVydmFsO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWluX2ludGVydmFsID0gaW50ZXJ2YWw7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBSZXN0b3JlIG1pbl9pbnRlcnZhbCBvcHRpb24gdG8gb3JpZ2luYWxcXG4gICAgICAgICAqL1xcbiAgICAgICAgcmVzdG9yZU9yaWdpbmFsTWluSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5vbGRfbWluX2ludGVydmFsICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5taW5faW50ZXJ2YWwgPSB0aGlzLm9sZF9taW5faW50ZXJ2YWw7XFxuICAgICAgICAgICAgICAgIHRoaXMub2xkX21pbl9pbnRlcnZhbCA9IG51bGw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG5cXG5cXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICAgIC8vIENhbGN1bGF0aW9uc1xcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBBbGwgY2FsY3VsYXRpb25zIGFuZCBtZWFzdXJlcyBzdGFydCBoZXJlXFxuICAgICAgICAgKlxcbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZSB7Ym9vbGVhbj19XFxuICAgICAgICAgKi9cXG4gICAgICAgIGNhbGM6IGZ1bmN0aW9uICh1cGRhdGUpIHtcXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuY2FsY19jb3VudCsrO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGNfY291bnQgPT09IDEwIHx8IHVwZGF0ZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNfY291bnQgPSAwO1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy53X3JzID0gdGhpcy4kY2FjaGUucnMub3V0ZXJXaWR0aChmYWxzZSk7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0hhbmRsZVBlcmNlbnQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvb3Jkcy53X3JzKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5jYWxjUG9pbnRlclBlcmNlbnQoKTtcXG4gICAgICAgICAgICB2YXIgaGFuZGxlX3ggPSB0aGlzLmdldEhhbmRsZVgoKTtcXG5cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IFxcXCJib3RoXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2dhcCA9IDA7XFxuICAgICAgICAgICAgICAgIGhhbmRsZV94ID0gdGhpcy5nZXRIYW5kbGVYKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gXFxcImNsaWNrXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2dhcCA9IHRoaXMuY29vcmRzLnBfaGFuZGxlIC8gMjtcXG4gICAgICAgICAgICAgICAgaGFuZGxlX3ggPSB0aGlzLmdldEhhbmRsZVgoKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnX2ludGVydmFsKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IFxcXCJib3RoX29uZVxcXCI7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuY2hvb3NlSGFuZGxlKGhhbmRsZV94KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFyZ2V0KSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgXFxcImJhc2VcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAodGhpcy5vcHRpb25zLm1heCAtIHRoaXMub3B0aW9ucy5taW4pIC8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAodGhpcy5yZXN1bHQuZnJvbSAtIHRoaXMub3B0aW9ucy5taW4pIC8gdyxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHRoaXMucmVzdWx0LnRvIC0gdGhpcy5vcHRpb25zLm1pbikgLyB3O1xcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9zaW5nbGVfcmVhbCA9IHRoaXMudG9GaXhlZChmKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsID0gdGhpcy50b0ZpeGVkKGYpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF90b19yZWFsID0gdGhpcy50b0ZpeGVkKHQpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9zaW5nbGVfcmVhbCA9IHRoaXMuY2hlY2tEaWFwYXNvbih0aGlzLmNvb3Jkcy5wX3NpbmdsZV9yZWFsLCB0aGlzLm9wdGlvbnMuZnJvbV9taW4sIHRoaXMub3B0aW9ucy5mcm9tX21heCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCA9IHRoaXMuY2hlY2tEaWFwYXNvbih0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCwgdGhpcy5vcHRpb25zLmZyb21fbWluLCB0aGlzLm9wdGlvbnMuZnJvbV9tYXgpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF90b19yZWFsID0gdGhpcy5jaGVja0RpYXBhc29uKHRoaXMuY29vcmRzLnBfdG9fcmVhbCwgdGhpcy5vcHRpb25zLnRvX21pbiwgdGhpcy5vcHRpb25zLnRvX21heCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3NpbmdsZV9mYWtlID0gdGhpcy5jb252ZXJ0VG9GYWtlUGVyY2VudCh0aGlzLmNvb3Jkcy5wX3NpbmdsZV9yZWFsKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZnJvbV9mYWtlID0gdGhpcy5jb252ZXJ0VG9GYWtlUGVyY2VudCh0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3RvX2Zha2UgPSB0aGlzLmNvbnZlcnRUb0Zha2VQZXJjZW50KHRoaXMuY29vcmRzLnBfdG9fcmVhbCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XFxuXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSBcXFwic2luZ2xlXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbV9maXhlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9zaW5nbGVfcmVhbCA9IHRoaXMuY29udmVydFRvUmVhbFBlcmNlbnQoaGFuZGxlX3gpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9zaW5nbGVfcmVhbCA9IHRoaXMuY2FsY1dpdGhTdGVwKHRoaXMuY29vcmRzLnBfc2luZ2xlX3JlYWwpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9zaW5nbGVfcmVhbCA9IHRoaXMuY2hlY2tEaWFwYXNvbih0aGlzLmNvb3Jkcy5wX3NpbmdsZV9yZWFsLCB0aGlzLm9wdGlvbnMuZnJvbV9taW4sIHRoaXMub3B0aW9ucy5mcm9tX21heCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3NpbmdsZV9mYWtlID0gdGhpcy5jb252ZXJ0VG9GYWtlUGVyY2VudCh0aGlzLmNvb3Jkcy5wX3NpbmdsZV9yZWFsKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJmcm9tXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbV9maXhlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9mcm9tX3JlYWwgPSB0aGlzLmNvbnZlcnRUb1JlYWxQZXJjZW50KGhhbmRsZV94KTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsID0gdGhpcy5jYWxjV2l0aFN0ZXAodGhpcy5jb29yZHMucF9mcm9tX3JlYWwpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsID4gdGhpcy5jb29yZHMucF90b19yZWFsKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9mcm9tX3JlYWwgPSB0aGlzLmNvb3Jkcy5wX3RvX3JlYWw7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCA9IHRoaXMuY2hlY2tEaWFwYXNvbih0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCwgdGhpcy5vcHRpb25zLmZyb21fbWluLCB0aGlzLm9wdGlvbnMuZnJvbV9tYXgpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9mcm9tX3JlYWwgPSB0aGlzLmNoZWNrTWluSW50ZXJ2YWwodGhpcy5jb29yZHMucF9mcm9tX3JlYWwsIHRoaXMuY29vcmRzLnBfdG9fcmVhbCwgXFxcImZyb21cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsID0gdGhpcy5jaGVja01heEludGVydmFsKHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsLCB0aGlzLmNvb3Jkcy5wX3RvX3JlYWwsIFxcXCJmcm9tXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2Zyb21fZmFrZSA9IHRoaXMuY29udmVydFRvRmFrZVBlcmNlbnQodGhpcy5jb29yZHMucF9mcm9tX3JlYWwpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICAgIGNhc2UgXFxcInRvXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG9fZml4ZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fcmVhbCA9IHRoaXMuY29udmVydFRvUmVhbFBlcmNlbnQoaGFuZGxlX3gpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF90b19yZWFsID0gdGhpcy5jYWxjV2l0aFN0ZXAodGhpcy5jb29yZHMucF90b19yZWFsKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvb3Jkcy5wX3RvX3JlYWwgPCB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fcmVhbCA9IHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF90b19yZWFsID0gdGhpcy5jaGVja0RpYXBhc29uKHRoaXMuY29vcmRzLnBfdG9fcmVhbCwgdGhpcy5vcHRpb25zLnRvX21pbiwgdGhpcy5vcHRpb25zLnRvX21heCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3RvX3JlYWwgPSB0aGlzLmNoZWNrTWluSW50ZXJ2YWwodGhpcy5jb29yZHMucF90b19yZWFsLCB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCwgXFxcInRvXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3RvX3JlYWwgPSB0aGlzLmNoZWNrTWF4SW50ZXJ2YWwodGhpcy5jb29yZHMucF90b19yZWFsLCB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCwgXFxcInRvXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3RvX2Zha2UgPSB0aGlzLmNvbnZlcnRUb0Zha2VQZXJjZW50KHRoaXMuY29vcmRzLnBfdG9fcmVhbCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSBcXFwiYm90aFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZyb21fZml4ZWQgfHwgdGhpcy5vcHRpb25zLnRvX2ZpeGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVfeCA9IHRoaXMudG9GaXhlZChoYW5kbGVfeCArICh0aGlzLmNvb3Jkcy5wX2hhbmRsZSAqIDAuMDAxKSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCA9IHRoaXMuY29udmVydFRvUmVhbFBlcmNlbnQoaGFuZGxlX3gpIC0gdGhpcy5jb29yZHMucF9nYXBfbGVmdDtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsID0gdGhpcy5jYWxjV2l0aFN0ZXAodGhpcy5jb29yZHMucF9mcm9tX3JlYWwpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9mcm9tX3JlYWwgPSB0aGlzLmNoZWNrRGlhcGFzb24odGhpcy5jb29yZHMucF9mcm9tX3JlYWwsIHRoaXMub3B0aW9ucy5mcm9tX21pbiwgdGhpcy5vcHRpb25zLmZyb21fbWF4KTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsID0gdGhpcy5jaGVja01pbkludGVydmFsKHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsLCB0aGlzLmNvb3Jkcy5wX3RvX3JlYWwsIFxcXCJmcm9tXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2Zyb21fZmFrZSA9IHRoaXMuY29udmVydFRvRmFrZVBlcmNlbnQodGhpcy5jb29yZHMucF9mcm9tX3JlYWwpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF90b19yZWFsID0gdGhpcy5jb252ZXJ0VG9SZWFsUGVyY2VudChoYW5kbGVfeCkgKyB0aGlzLmNvb3Jkcy5wX2dhcF9yaWdodDtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fcmVhbCA9IHRoaXMuY2FsY1dpdGhTdGVwKHRoaXMuY29vcmRzLnBfdG9fcmVhbCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3RvX3JlYWwgPSB0aGlzLmNoZWNrRGlhcGFzb24odGhpcy5jb29yZHMucF90b19yZWFsLCB0aGlzLm9wdGlvbnMudG9fbWluLCB0aGlzLm9wdGlvbnMudG9fbWF4KTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fcmVhbCA9IHRoaXMuY2hlY2tNaW5JbnRlcnZhbCh0aGlzLmNvb3Jkcy5wX3RvX3JlYWwsIHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsLCBcXFwidG9cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fZmFrZSA9IHRoaXMuY29udmVydFRvRmFrZVBlcmNlbnQodGhpcy5jb29yZHMucF90b19yZWFsKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJib3RoX29uZVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZyb21fZml4ZWQgfHwgdGhpcy5vcHRpb25zLnRvX2ZpeGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhbF94ID0gdGhpcy5jb252ZXJ0VG9SZWFsUGVyY2VudChoYW5kbGVfeCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHRoaXMucmVzdWx0LmZyb21fcGVyY2VudCxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IHRoaXMucmVzdWx0LnRvX3BlcmNlbnQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbCA9IHRvIC0gZnJvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBoYWxmID0gZnVsbCAvIDIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2Zyb20gPSByZWFsX3ggLSBoYWxmLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld190byA9IHJlYWxfeCArIGhhbGY7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3X2Zyb20gPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2Zyb20gPSAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld190byA9IG5ld19mcm9tICsgZnVsbDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdfdG8gPiAxMDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfdG8gPSAxMDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2Zyb20gPSBuZXdfdG8gLSBmdWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9mcm9tX3JlYWwgPSB0aGlzLmNhbGNXaXRoU3RlcChuZXdfZnJvbSk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCA9IHRoaXMuY2hlY2tEaWFwYXNvbih0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCwgdGhpcy5vcHRpb25zLmZyb21fbWluLCB0aGlzLm9wdGlvbnMuZnJvbV9tYXgpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9mcm9tX2Zha2UgPSB0aGlzLmNvbnZlcnRUb0Zha2VQZXJjZW50KHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fcmVhbCA9IHRoaXMuY2FsY1dpdGhTdGVwKG5ld190byk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5wX3RvX3JlYWwgPSB0aGlzLmNoZWNrRGlhcGFzb24odGhpcy5jb29yZHMucF90b19yZWFsLCB0aGlzLm9wdGlvbnMudG9fbWluLCB0aGlzLm9wdGlvbnMudG9fbWF4KTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfdG9fZmFrZSA9IHRoaXMuY29udmVydFRvRmFrZVBlcmNlbnQodGhpcy5jb29yZHMucF90b19yZWFsKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfYmFyX3ggPSAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAyKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9iYXJfdyA9IHRoaXMuY29vcmRzLnBfc2luZ2xlX2Zha2U7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb21fcGVyY2VudCA9IHRoaXMuY29vcmRzLnBfc2luZ2xlX3JlYWw7XFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb20gPSB0aGlzLmNvbnZlcnRUb1ZhbHVlKHRoaXMuY29vcmRzLnBfc2luZ2xlX3JlYWwpO1xcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5mcm9tX3ByZXR0eSA9IHRoaXMuX3ByZXR0aWZ5KHRoaXMucmVzdWx0LmZyb20pO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb21fdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWVzW3RoaXMucmVzdWx0LmZyb21dO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9iYXJfeCA9IHRoaXMudG9GaXhlZCh0aGlzLmNvb3Jkcy5wX2Zyb21fZmFrZSArICh0aGlzLmNvb3Jkcy5wX2hhbmRsZSAvIDIpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9iYXJfdyA9IHRoaXMudG9GaXhlZCh0aGlzLmNvb3Jkcy5wX3RvX2Zha2UgLSB0aGlzLmNvb3Jkcy5wX2Zyb21fZmFrZSk7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb21fcGVyY2VudCA9IHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsO1xcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5mcm9tID0gdGhpcy5jb252ZXJ0VG9WYWx1ZSh0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCk7XFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb21fcHJldHR5ID0gdGhpcy5fcHJldHRpZnkodGhpcy5yZXN1bHQuZnJvbSk7XFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRvX3BlcmNlbnQgPSB0aGlzLmNvb3Jkcy5wX3RvX3JlYWw7XFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRvID0gdGhpcy5jb252ZXJ0VG9WYWx1ZSh0aGlzLmNvb3Jkcy5wX3RvX3JlYWwpO1xcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b19wcmV0dHkgPSB0aGlzLl9wcmV0dGlmeSh0aGlzLnJlc3VsdC50byk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQuZnJvbV92YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZXNbdGhpcy5yZXN1bHQuZnJvbV07XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b192YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZXNbdGhpcy5yZXN1bHQudG9dO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuY2FsY01pbk1heCgpO1xcbiAgICAgICAgICAgIHRoaXMuY2FsY0xhYmVscygpO1xcbiAgICAgICAgfSxcXG5cXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogY2FsY3VsYXRlcyBwb2ludGVyIFggaW4gcGVyY2VudFxcbiAgICAgICAgICovXFxuICAgICAgICBjYWxjUG9pbnRlclBlcmNlbnQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29vcmRzLndfcnMpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMucF9wb2ludGVyID0gMDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5jb29yZHMueF9wb2ludGVyIDwgMCB8fCBpc05hTih0aGlzLmNvb3Jkcy54X3BvaW50ZXIpICApIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMueF9wb2ludGVyID0gMDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29vcmRzLnhfcG9pbnRlciA+IHRoaXMuY29vcmRzLndfcnMpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMueF9wb2ludGVyID0gdGhpcy5jb29yZHMud19ycztcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5jb29yZHMucF9wb2ludGVyID0gdGhpcy50b0ZpeGVkKHRoaXMuY29vcmRzLnhfcG9pbnRlciAvIHRoaXMuY29vcmRzLndfcnMgKiAxMDApO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGNvbnZlcnRUb1JlYWxQZXJjZW50OiBmdW5jdGlvbiAoZmFrZSkge1xcbiAgICAgICAgICAgIHZhciBmdWxsID0gMTAwIC0gdGhpcy5jb29yZHMucF9oYW5kbGU7XFxuICAgICAgICAgICAgcmV0dXJuIGZha2UgLyBmdWxsICogMTAwO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGNvbnZlcnRUb0Zha2VQZXJjZW50OiBmdW5jdGlvbiAocmVhbCkge1xcbiAgICAgICAgICAgIHZhciBmdWxsID0gMTAwIC0gdGhpcy5jb29yZHMucF9oYW5kbGU7XFxuICAgICAgICAgICAgcmV0dXJuIHJlYWwgLyAxMDAgKiBmdWxsO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGdldEhhbmRsZVg6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgbWF4ID0gMTAwIC0gdGhpcy5jb29yZHMucF9oYW5kbGUsXFxuICAgICAgICAgICAgICAgIHggPSB0aGlzLnRvRml4ZWQodGhpcy5jb29yZHMucF9wb2ludGVyIC0gdGhpcy5jb29yZHMucF9nYXApO1xcblxcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xcbiAgICAgICAgICAgICAgICB4ID0gMDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHggPiBtYXgpIHtcXG4gICAgICAgICAgICAgICAgeCA9IG1heDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHg7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgY2FsY0hhbmRsZVBlcmNlbnQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLndfaGFuZGxlID0gdGhpcy4kY2FjaGUuc19zaW5nbGUub3V0ZXJXaWR0aChmYWxzZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMud19oYW5kbGUgPSB0aGlzLiRjYWNoZS5zX2Zyb20ub3V0ZXJXaWR0aChmYWxzZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuY29vcmRzLnBfaGFuZGxlID0gdGhpcy50b0ZpeGVkKHRoaXMuY29vcmRzLndfaGFuZGxlIC8gdGhpcy5jb29yZHMud19ycyAqIDEwMCk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaW5kIGNsb3Nlc3QgaGFuZGxlIHRvIHBvaW50ZXIgY2xpY2tcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gcmVhbF94IHtOdW1iZXJ9XFxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxcbiAgICAgICAgICovXFxuICAgICAgICBjaG9vc2VIYW5kbGU6IGZ1bmN0aW9uIChyZWFsX3gpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwic2luZ2xlXFxcIjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YXIgbV9wb2ludCA9IHRoaXMuY29vcmRzLnBfZnJvbV9yZWFsICsgKCh0aGlzLmNvb3Jkcy5wX3RvX3JlYWwgLSB0aGlzLmNvb3Jkcy5wX2Zyb21fcmVhbCkgLyAyKTtcXG4gICAgICAgICAgICAgICAgaWYgKHJlYWxfeCA+PSBtX3BvaW50KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRvX2ZpeGVkID8gXFxcImZyb21cXFwiIDogXFxcInRvXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnJvbV9maXhlZCA/IFxcXCJ0b1xcXCIgOiBcXFwiZnJvbVxcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBNZWFzdXJlIE1pbiBhbmQgTWF4IGxhYmVscyB3aWR0aCBpbiBwZXJjZW50XFxuICAgICAgICAgKi9cXG4gICAgICAgIGNhbGNNaW5NYXg6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29vcmRzLndfcnMpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLmxhYmVscy5wX21pbiA9IHRoaXMubGFiZWxzLndfbWluIC8gdGhpcy5jb29yZHMud19ycyAqIDEwMDtcXG4gICAgICAgICAgICB0aGlzLmxhYmVscy5wX21heCA9IHRoaXMubGFiZWxzLndfbWF4IC8gdGhpcy5jb29yZHMud19ycyAqIDEwMDtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE1lYXN1cmUgbGFiZWxzIHdpZHRoIGFuZCBYIGluIHBlcmNlbnRcXG4gICAgICAgICAqL1xcbiAgICAgICAgY2FsY0xhYmVsczogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5jb29yZHMud19ycyB8fCB0aGlzLm9wdGlvbnMuaGlkZV9mcm9tX3RvKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBcXFwic2luZ2xlXFxcIikge1xcblxcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy53X3NpbmdsZSA9IHRoaXMuJGNhY2hlLnNpbmdsZS5vdXRlcldpZHRoKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucF9zaW5nbGVfZmFrZSA9IHRoaXMubGFiZWxzLndfc2luZ2xlIC8gdGhpcy5jb29yZHMud19ycyAqIDEwMDtcXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucF9zaW5nbGVfbGVmdCA9IHRoaXMuY29vcmRzLnBfc2luZ2xlX2Zha2UgKyAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAyKSAtICh0aGlzLmxhYmVscy5wX3NpbmdsZV9mYWtlIC8gMik7XFxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnBfc2luZ2xlX2xlZnQgPSB0aGlzLmNoZWNrRWRnZXModGhpcy5sYWJlbHMucF9zaW5nbGVfbGVmdCwgdGhpcy5sYWJlbHMucF9zaW5nbGVfZmFrZSk7XFxuXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG5cXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMud19mcm9tID0gdGhpcy4kY2FjaGUuZnJvbS5vdXRlcldpZHRoKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucF9mcm9tX2Zha2UgPSB0aGlzLmxhYmVscy53X2Zyb20gLyB0aGlzLmNvb3Jkcy53X3JzICogMTAwO1xcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wX2Zyb21fbGVmdCA9IHRoaXMuY29vcmRzLnBfZnJvbV9mYWtlICsgKHRoaXMuY29vcmRzLnBfaGFuZGxlIC8gMikgLSAodGhpcy5sYWJlbHMucF9mcm9tX2Zha2UgLyAyKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucF9mcm9tX2xlZnQgPSB0aGlzLnRvRml4ZWQodGhpcy5sYWJlbHMucF9mcm9tX2xlZnQpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wX2Zyb21fbGVmdCA9IHRoaXMuY2hlY2tFZGdlcyh0aGlzLmxhYmVscy5wX2Zyb21fbGVmdCwgdGhpcy5sYWJlbHMucF9mcm9tX2Zha2UpO1xcblxcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy53X3RvID0gdGhpcy4kY2FjaGUudG8ub3V0ZXJXaWR0aChmYWxzZSk7XFxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnBfdG9fZmFrZSA9IHRoaXMubGFiZWxzLndfdG8gLyB0aGlzLmNvb3Jkcy53X3JzICogMTAwO1xcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wX3RvX2xlZnQgPSB0aGlzLmNvb3Jkcy5wX3RvX2Zha2UgKyAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAyKSAtICh0aGlzLmxhYmVscy5wX3RvX2Zha2UgLyAyKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucF90b19sZWZ0ID0gdGhpcy50b0ZpeGVkKHRoaXMubGFiZWxzLnBfdG9fbGVmdCk7XFxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnBfdG9fbGVmdCA9IHRoaXMuY2hlY2tFZGdlcyh0aGlzLmxhYmVscy5wX3RvX2xlZnQsIHRoaXMubGFiZWxzLnBfdG9fZmFrZSk7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLndfc2luZ2xlID0gdGhpcy4kY2FjaGUuc2luZ2xlLm91dGVyV2lkdGgoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wX3NpbmdsZV9mYWtlID0gdGhpcy5sYWJlbHMud19zaW5nbGUgLyB0aGlzLmNvb3Jkcy53X3JzICogMTAwO1xcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wX3NpbmdsZV9sZWZ0ID0gKCh0aGlzLmxhYmVscy5wX2Zyb21fbGVmdCArIHRoaXMubGFiZWxzLnBfdG9fbGVmdCArIHRoaXMubGFiZWxzLnBfdG9fZmFrZSkgLyAyKSAtICh0aGlzLmxhYmVscy5wX3NpbmdsZV9mYWtlIC8gMik7XFxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnBfc2luZ2xlX2xlZnQgPSB0aGlzLnRvRml4ZWQodGhpcy5sYWJlbHMucF9zaW5nbGVfbGVmdCk7XFxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnBfc2luZ2xlX2xlZnQgPSB0aGlzLmNoZWNrRWRnZXModGhpcy5sYWJlbHMucF9zaW5nbGVfbGVmdCwgdGhpcy5sYWJlbHMucF9zaW5nbGVfZmFrZSk7XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG5cXG5cXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICAgIC8vIERyYXdpbmdzXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE1haW4gZnVuY3Rpb24gY2FsbGVkIGluIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lXFxuICAgICAgICAgKiB0byB1cGRhdGUgZXZlcnl0aGluZ1xcbiAgICAgICAgICovXFxuICAgICAgICB1cGRhdGVTY2VuZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZl9pZCkge1xcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZl9pZCk7XFxuICAgICAgICAgICAgICAgIHRoaXMucmFmX2lkID0gbnVsbDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBkYXRlX3RtKTtcXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV90bSA9IG51bGw7XFxuXFxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLmRyYXdIYW5kbGVzKCk7XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNfYWN0aXZlKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlU2NlbmUuYmluZCh0aGlzKSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVfdG0gPSBzZXRUaW1lb3V0KHRoaXMudXBkYXRlU2NlbmUuYmluZCh0aGlzKSwgMzAwKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBEcmF3IGhhbmRsZXNcXG4gICAgICAgICAqL1xcbiAgICAgICAgZHJhd0hhbmRsZXM6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLmNvb3Jkcy53X3JzID0gdGhpcy4kY2FjaGUucnMub3V0ZXJXaWR0aChmYWxzZSk7XFxuXFxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvb3Jkcy53X3JzKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMuY29vcmRzLndfcnMgIT09IHRoaXMuY29vcmRzLndfcnNfb2xkKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gXFxcImJhc2VcXFwiO1xcbiAgICAgICAgICAgICAgICB0aGlzLmlzX3Jlc2l6ZSA9IHRydWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLmNvb3Jkcy53X3JzICE9PSB0aGlzLmNvb3Jkcy53X3JzX29sZCB8fCB0aGlzLmZvcmNlX3JlZHJhdykge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1pbk1heCgpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGModHJ1ZSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscygpO1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdyaWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY0dyaWRNYXJnaW4oKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY0dyaWRMYWJlbHMoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlX3JlZHJhdyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzLndfcnNfb2xkID0gdGhpcy5jb29yZHMud19ycztcXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2hhZG93KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICghdGhpcy5jb29yZHMud19ycykge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmFnZ2luZyAmJiAhdGhpcy5mb3JjZV9yZWRyYXcgJiYgIXRoaXMuaXNfa2V5KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub2xkX2Zyb20gIT09IHRoaXMucmVzdWx0LmZyb20gfHwgdGhpcy5vbGRfdG8gIT09IHRoaXMucmVzdWx0LnRvIHx8IHRoaXMuZm9yY2VfcmVkcmF3IHx8IHRoaXMuaXNfa2V5KSB7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscygpO1xcblxcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5iYXJbMF0uc3R5bGUubGVmdCA9IHRoaXMuY29vcmRzLnBfYmFyX3ggKyBcXFwiJVxcXCI7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmJhclswXS5zdHlsZS53aWR0aCA9IHRoaXMuY29vcmRzLnBfYmFyX3cgKyBcXFwiJVxcXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gXFxcInNpbmdsZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmJhclswXS5zdHlsZS5sZWZ0ID0gMDtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmJhclswXS5zdHlsZS53aWR0aCA9IHRoaXMuY29vcmRzLnBfYmFyX3cgKyB0aGlzLmNvb3Jkcy5wX2Jhcl94ICsgXFxcIiVcXFwiO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc19zaW5nbGVbMF0uc3R5bGUubGVmdCA9IHRoaXMuY29vcmRzLnBfc2luZ2xlX2Zha2UgKyBcXFwiJVxcXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaW5nbGVbMF0uc3R5bGUubGVmdCA9IHRoaXMubGFiZWxzLnBfc2luZ2xlX2xlZnQgKyBcXFwiJVxcXCI7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zX2Zyb21bMF0uc3R5bGUubGVmdCA9IHRoaXMuY29vcmRzLnBfZnJvbV9mYWtlICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc190b1swXS5zdHlsZS5sZWZ0ID0gdGhpcy5jb29yZHMucF90b19mYWtlICsgXFxcIiVcXFwiO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2xkX2Zyb20gIT09IHRoaXMucmVzdWx0LmZyb20gfHwgdGhpcy5mb3JjZV9yZWRyYXcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tWzBdLnN0eWxlLmxlZnQgPSB0aGlzLmxhYmVscy5wX2Zyb21fbGVmdCArIFxcXCIlXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9sZF90byAhPT0gdGhpcy5yZXN1bHQudG8gfHwgdGhpcy5mb3JjZV9yZWRyYXcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS50b1swXS5zdHlsZS5sZWZ0ID0gdGhpcy5sYWJlbHMucF90b19sZWZ0ICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlWzBdLnN0eWxlLmxlZnQgPSB0aGlzLmxhYmVscy5wX3NpbmdsZV9sZWZ0ICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVUb0lucHV0KCk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5vbGRfZnJvbSAhPT0gdGhpcy5yZXN1bHQuZnJvbSB8fCB0aGlzLm9sZF90byAhPT0gdGhpcy5yZXN1bHQudG8pICYmICF0aGlzLmlzX3N0YXJ0KSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5pbnB1dC50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LnRyaWdnZXIoXFxcImlucHV0XFxcIik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhpcy5vbGRfZnJvbSA9IHRoaXMucmVzdWx0LmZyb207XFxuICAgICAgICAgICAgICAgIHRoaXMub2xkX3RvID0gdGhpcy5yZXN1bHQudG87XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrcyBjYWxsXFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc19yZXNpemUgJiYgIXRoaXMuaXNfdXBkYXRlICYmICF0aGlzLmlzX3N0YXJ0ICYmICF0aGlzLmlzX2ZpbmlzaCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsT25DaGFuZ2UoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc19rZXkgfHwgdGhpcy5pc19jbGljaykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc19rZXkgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNfY2xpY2sgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbE9uRmluaXNoKCk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhpcy5pc191cGRhdGUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5pc19yZXNpemUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5pc19maW5pc2ggPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5pc19zdGFydCA9IGZhbHNlO1xcbiAgICAgICAgICAgIHRoaXMuaXNfa2V5ID0gZmFsc2U7XFxuICAgICAgICAgICAgdGhpcy5pc19jbGljayA9IGZhbHNlO1xcbiAgICAgICAgICAgIHRoaXMuZm9yY2VfcmVkcmF3ID0gZmFsc2U7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBEcmF3IGxhYmVsc1xcbiAgICAgICAgICogbWVhc3VyZSBsYWJlbHMgY29sbGlzaW9uc1xcbiAgICAgICAgICogY29sbGFwc2UgY2xvc2UgbGFiZWxzXFxuICAgICAgICAgKi9cXG4gICAgICAgIGRyYXdMYWJlbHM6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhciB2YWx1ZXNfbnVtID0gdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7XFxuICAgICAgICAgICAgdmFyIHBfdmFsdWVzID0gdGhpcy5vcHRpb25zLnBfdmFsdWVzO1xcbiAgICAgICAgICAgIHZhciB0ZXh0X3NpbmdsZTtcXG4gICAgICAgICAgICB2YXIgdGV4dF9mcm9tO1xcbiAgICAgICAgICAgIHZhciB0ZXh0X3RvO1xcbiAgICAgICAgICAgIHZhciBmcm9tX3ByZXR0eTtcXG4gICAgICAgICAgICB2YXIgdG9fcHJldHR5O1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZV9mcm9tX3RvKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBcXFwic2luZ2xlXFxcIikge1xcblxcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzX251bSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9zaW5nbGUgPSB0aGlzLmRlY29yYXRlKHBfdmFsdWVzW3RoaXMucmVzdWx0LmZyb21dKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNpbmdsZS5odG1sKHRleHRfc2luZ2xlKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGZyb21fcHJldHR5ID0gdGhpcy5fcHJldHRpZnkodGhpcy5yZXN1bHQuZnJvbSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0X3NpbmdsZSA9IHRoaXMuZGVjb3JhdGUoZnJvbV9wcmV0dHksIHRoaXMucmVzdWx0LmZyb20pO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlLmh0bWwodGV4dF9zaW5nbGUpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0xhYmVscygpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYWJlbHMucF9zaW5nbGVfbGVmdCA8IHRoaXMubGFiZWxzLnBfbWluICsgMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUubWluWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1pblswXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcInZpc2libGVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhYmVscy5wX3NpbmdsZV9sZWZ0ICsgdGhpcy5sYWJlbHMucF9zaW5nbGVfZmFrZSA+IDEwMCAtIHRoaXMubGFiZWxzLnBfbWF4IC0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUubWF4WzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1heFswXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcInZpc2libGVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc19udW0pIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVjb3JhdGVfYm90aCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfc2luZ2xlID0gdGhpcy5kZWNvcmF0ZShwX3ZhbHVlc1t0aGlzLnJlc3VsdC5mcm9tXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9zaW5nbGUgKz0gdGhpcy5vcHRpb25zLnZhbHVlc19zZXBhcmF0b3I7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9zaW5nbGUgKz0gdGhpcy5kZWNvcmF0ZShwX3ZhbHVlc1t0aGlzLnJlc3VsdC50b10pO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3NpbmdsZSA9IHRoaXMuZGVjb3JhdGUocF92YWx1ZXNbdGhpcy5yZXN1bHQuZnJvbV0gKyB0aGlzLm9wdGlvbnMudmFsdWVzX3NlcGFyYXRvciArIHBfdmFsdWVzW3RoaXMucmVzdWx0LnRvXSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2Zyb20gPSB0aGlzLmRlY29yYXRlKHBfdmFsdWVzW3RoaXMucmVzdWx0LmZyb21dKTtcXG4gICAgICAgICAgICAgICAgICAgIHRleHRfdG8gPSB0aGlzLmRlY29yYXRlKHBfdmFsdWVzW3RoaXMucmVzdWx0LnRvXSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5zaW5nbGUuaHRtbCh0ZXh0X3NpbmdsZSk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tLmh0bWwodGV4dF9mcm9tKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnRvLmh0bWwodGV4dF90byk7XFxuXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBmcm9tX3ByZXR0eSA9IHRoaXMuX3ByZXR0aWZ5KHRoaXMucmVzdWx0LmZyb20pO1xcbiAgICAgICAgICAgICAgICAgICAgdG9fcHJldHR5ID0gdGhpcy5fcHJldHRpZnkodGhpcy5yZXN1bHQudG8pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWNvcmF0ZV9ib3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9zaW5nbGUgPSB0aGlzLmRlY29yYXRlKGZyb21fcHJldHR5LCB0aGlzLnJlc3VsdC5mcm9tKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3NpbmdsZSArPSB0aGlzLm9wdGlvbnMudmFsdWVzX3NlcGFyYXRvcjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3NpbmdsZSArPSB0aGlzLmRlY29yYXRlKHRvX3ByZXR0eSwgdGhpcy5yZXN1bHQudG8pO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3NpbmdsZSA9IHRoaXMuZGVjb3JhdGUoZnJvbV9wcmV0dHkgKyB0aGlzLm9wdGlvbnMudmFsdWVzX3NlcGFyYXRvciArIHRvX3ByZXR0eSwgdGhpcy5yZXN1bHQudG8pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9mcm9tID0gdGhpcy5kZWNvcmF0ZShmcm9tX3ByZXR0eSwgdGhpcy5yZXN1bHQuZnJvbSk7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0X3RvID0gdGhpcy5kZWNvcmF0ZSh0b19wcmV0dHksIHRoaXMucmVzdWx0LnRvKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNpbmdsZS5odG1sKHRleHRfc2luZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmZyb20uaHRtbCh0ZXh0X2Zyb20pO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUudG8uaHRtbCh0ZXh0X3RvKTtcXG5cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNMYWJlbHMoKTtcXG5cXG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMubGFiZWxzLnBfc2luZ2xlX2xlZnQsIHRoaXMubGFiZWxzLnBfZnJvbV9sZWZ0KSxcXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZV9sZWZ0ID0gdGhpcy5sYWJlbHMucF9zaW5nbGVfbGVmdCArIHRoaXMubGFiZWxzLnBfc2luZ2xlX2Zha2UsXFxuICAgICAgICAgICAgICAgICAgICB0b19sZWZ0ID0gdGhpcy5sYWJlbHMucF90b19sZWZ0ICsgdGhpcy5sYWJlbHMucF90b19mYWtlLFxcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoc2luZ2xlX2xlZnQsIHRvX2xlZnQpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYWJlbHMucF9mcm9tX2xlZnQgKyB0aGlzLmxhYmVscy5wX2Zyb21fZmFrZSA+PSB0aGlzLmxhYmVscy5wX3RvX2xlZnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmZyb21bMF0uc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUudG9bMF0uc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwidmlzaWJsZVxcXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQuZnJvbSA9PT0gdGhpcy5yZXN1bHQudG8pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IFxcXCJmcm9tXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwidmlzaWJsZVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gXFxcInRvXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS50b1swXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcInZpc2libGVcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMudGFyZ2V0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmZyb21bMF0uc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJ2aXNpYmxlXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB0b19sZWZ0O1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5mcm9tWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS50b1swXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcImhpZGRlblxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuc2luZ2xlWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwidmlzaWJsZVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoc2luZ2xlX2xlZnQsIHRvX2xlZnQpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuZnJvbVswXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcInZpc2libGVcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUudG9bMF0uc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJ2aXNpYmxlXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLnNpbmdsZVswXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcImhpZGRlblxcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA8IHRoaXMubGFiZWxzLnBfbWluICsgMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUubWluWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1pblswXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcInZpc2libGVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChtYXggPiAxMDAgLSB0aGlzLmxhYmVscy5wX21heCAtIDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLm1heFswXS5zdHlsZS52aXNpYmlsaXR5ID0gXFxcImhpZGRlblxcXCI7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5tYXhbMF0uc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJ2aXNpYmxlXFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIERyYXcgc2hhZG93IGludGVydmFsc1xcbiAgICAgICAgICovXFxuICAgICAgICBkcmF3U2hhZG93OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLiRjYWNoZSxcXG5cXG4gICAgICAgICAgICAgICAgaXNfZnJvbV9taW4gPSB0eXBlb2Ygby5mcm9tX21pbiA9PT0gXFxcIm51bWJlclxcXCIgJiYgIWlzTmFOKG8uZnJvbV9taW4pLFxcbiAgICAgICAgICAgICAgICBpc19mcm9tX21heCA9IHR5cGVvZiBvLmZyb21fbWF4ID09PSBcXFwibnVtYmVyXFxcIiAmJiAhaXNOYU4oby5mcm9tX21heCksXFxuICAgICAgICAgICAgICAgIGlzX3RvX21pbiA9IHR5cGVvZiBvLnRvX21pbiA9PT0gXFxcIm51bWJlclxcXCIgJiYgIWlzTmFOKG8udG9fbWluKSxcXG4gICAgICAgICAgICAgICAgaXNfdG9fbWF4ID0gdHlwZW9mIG8udG9fbWF4ID09PSBcXFwibnVtYmVyXFxcIiAmJiAhaXNOYU4oby50b19tYXgpLFxcblxcbiAgICAgICAgICAgICAgICBmcm9tX21pbixcXG4gICAgICAgICAgICAgICAgZnJvbV9tYXgsXFxuICAgICAgICAgICAgICAgIHRvX21pbixcXG4gICAgICAgICAgICAgICAgdG9fbWF4O1xcblxcbiAgICAgICAgICAgIGlmIChvLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGlmIChvLmZyb21fc2hhZG93ICYmIChpc19mcm9tX21pbiB8fCBpc19mcm9tX21heCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZyb21fbWluID0gdGhpcy5jb252ZXJ0VG9QZXJjZW50KGlzX2Zyb21fbWluID8gby5mcm9tX21pbiA6IG8ubWluKTtcXG4gICAgICAgICAgICAgICAgICAgIGZyb21fbWF4ID0gdGhpcy5jb252ZXJ0VG9QZXJjZW50KGlzX2Zyb21fbWF4ID8gby5mcm9tX21heCA6IG8ubWF4KSAtIGZyb21fbWluO1xcbiAgICAgICAgICAgICAgICAgICAgZnJvbV9taW4gPSB0aGlzLnRvRml4ZWQoZnJvbV9taW4gLSAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAxMDAgKiBmcm9tX21pbikpO1xcbiAgICAgICAgICAgICAgICAgICAgZnJvbV9tYXggPSB0aGlzLnRvRml4ZWQoZnJvbV9tYXggLSAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAxMDAgKiBmcm9tX21heCkpO1xcbiAgICAgICAgICAgICAgICAgICAgZnJvbV9taW4gPSBmcm9tX21pbiArICh0aGlzLmNvb3Jkcy5wX2hhbmRsZSAvIDIpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgYy5zaGFkX3NpbmdsZVswXS5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGMuc2hhZF9zaW5nbGVbMF0uc3R5bGUubGVmdCA9IGZyb21fbWluICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgYy5zaGFkX3NpbmdsZVswXS5zdHlsZS53aWR0aCA9IGZyb21fbWF4ICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgYy5zaGFkX3NpbmdsZVswXS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKG8uZnJvbV9zaGFkb3cgJiYgKGlzX2Zyb21fbWluIHx8IGlzX2Zyb21fbWF4KSkge1xcbiAgICAgICAgICAgICAgICAgICAgZnJvbV9taW4gPSB0aGlzLmNvbnZlcnRUb1BlcmNlbnQoaXNfZnJvbV9taW4gPyBvLmZyb21fbWluIDogby5taW4pO1xcbiAgICAgICAgICAgICAgICAgICAgZnJvbV9tYXggPSB0aGlzLmNvbnZlcnRUb1BlcmNlbnQoaXNfZnJvbV9tYXggPyBvLmZyb21fbWF4IDogby5tYXgpIC0gZnJvbV9taW47XFxuICAgICAgICAgICAgICAgICAgICBmcm9tX21pbiA9IHRoaXMudG9GaXhlZChmcm9tX21pbiAtICh0aGlzLmNvb3Jkcy5wX2hhbmRsZSAvIDEwMCAqIGZyb21fbWluKSk7XFxuICAgICAgICAgICAgICAgICAgICBmcm9tX21heCA9IHRoaXMudG9GaXhlZChmcm9tX21heCAtICh0aGlzLmNvb3Jkcy5wX2hhbmRsZSAvIDEwMCAqIGZyb21fbWF4KSk7XFxuICAgICAgICAgICAgICAgICAgICBmcm9tX21pbiA9IGZyb21fbWluICsgKHRoaXMuY29vcmRzLnBfaGFuZGxlIC8gMik7XFxuXFxuICAgICAgICAgICAgICAgICAgICBjLnNoYWRfZnJvbVswXS5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGMuc2hhZF9mcm9tWzBdLnN0eWxlLmxlZnQgPSBmcm9tX21pbiArIFxcXCIlXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGMuc2hhZF9mcm9tWzBdLnN0eWxlLndpZHRoID0gZnJvbV9tYXggKyBcXFwiJVxcXCI7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBjLnNoYWRfZnJvbVswXS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChvLnRvX3NoYWRvdyAmJiAoaXNfdG9fbWluIHx8IGlzX3RvX21heCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRvX21pbiA9IHRoaXMuY29udmVydFRvUGVyY2VudChpc190b19taW4gPyBvLnRvX21pbiA6IG8ubWluKTtcXG4gICAgICAgICAgICAgICAgICAgIHRvX21heCA9IHRoaXMuY29udmVydFRvUGVyY2VudChpc190b19tYXggPyBvLnRvX21heCA6IG8ubWF4KSAtIHRvX21pbjtcXG4gICAgICAgICAgICAgICAgICAgIHRvX21pbiA9IHRoaXMudG9GaXhlZCh0b19taW4gLSAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAxMDAgKiB0b19taW4pKTtcXG4gICAgICAgICAgICAgICAgICAgIHRvX21heCA9IHRoaXMudG9GaXhlZCh0b19tYXggLSAodGhpcy5jb29yZHMucF9oYW5kbGUgLyAxMDAgKiB0b19tYXgpKTtcXG4gICAgICAgICAgICAgICAgICAgIHRvX21pbiA9IHRvX21pbiArICh0aGlzLmNvb3Jkcy5wX2hhbmRsZSAvIDIpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgYy5zaGFkX3RvWzBdLnN0eWxlLmRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgYy5zaGFkX3RvWzBdLnN0eWxlLmxlZnQgPSB0b19taW4gKyBcXFwiJVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjLnNoYWRfdG9bMF0uc3R5bGUud2lkdGggPSB0b19tYXggKyBcXFwiJVxcXCI7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBjLnNoYWRfdG9bMF0uc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFdyaXRlIHZhbHVlcyB0byBpbnB1dCBlbGVtZW50XFxuICAgICAgICAgKi9cXG4gICAgICAgIHdyaXRlVG9JbnB1dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gXFxcInNpbmdsZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5pbnB1dC5wcm9wKFxcXCJ2YWx1ZVxcXCIsIHRoaXMucmVzdWx0LmZyb21fdmFsdWUpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuaW5wdXQucHJvcChcXFwidmFsdWVcXFwiLCB0aGlzLnJlc3VsdC5mcm9tKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5pbnB1dC5kYXRhKFxcXCJmcm9tXFxcIiwgdGhpcy5yZXN1bHQuZnJvbSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjYWNoZS5pbnB1dC5wcm9wKFxcXCJ2YWx1ZVxcXCIsIHRoaXMucmVzdWx0LmZyb21fdmFsdWUgKyB0aGlzLm9wdGlvbnMuaW5wdXRfdmFsdWVzX3NlcGFyYXRvciArIHRoaXMucmVzdWx0LnRvX3ZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LnByb3AoXFxcInZhbHVlXFxcIiwgdGhpcy5yZXN1bHQuZnJvbSArIHRoaXMub3B0aW9ucy5pbnB1dF92YWx1ZXNfc2VwYXJhdG9yICsgdGhpcy5yZXN1bHQudG8pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LmRhdGEoXFxcImZyb21cXFwiLCB0aGlzLnJlc3VsdC5mcm9tKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuaW5wdXQuZGF0YShcXFwidG9cXFwiLCB0aGlzLnJlc3VsdC50byk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG5cXG5cXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICAgIC8vIENhbGxiYWNrc1xcblxcbiAgICAgICAgY2FsbE9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLndyaXRlVG9JbnB1dCgpO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25TdGFydCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm9uU3RhcnQgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY29wZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uU3RhcnQuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHRoaXMucmVzdWx0KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblN0YXJ0KHRoaXMucmVzdWx0KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBjYWxsT25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLndyaXRlVG9JbnB1dCgpO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25DaGFuZ2UgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5vbkNoYW5nZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjb3BlKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25DaGFuZ2UuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHRoaXMucmVzdWx0KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNoYW5nZSh0aGlzLnJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY2FsbE9uRmluaXNoOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdGhpcy53cml0ZVRvSW5wdXQoKTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uRmluaXNoICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMub25GaW5pc2ggPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY29wZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmluaXNoLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCB0aGlzLnJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25GaW5pc2godGhpcy5yZXN1bHQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhbGxPblVwZGF0ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMud3JpdGVUb0lucHV0KCk7XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblVwZGF0ZSAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm9uVXBkYXRlID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NvcGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZS5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgdGhpcy5yZXN1bHQpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKHRoaXMucmVzdWx0KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuXFxuXFxuXFxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgICAgICAvLyBTZXJ2aWNlIG1ldGhvZHNcXG5cXG4gICAgICAgIHRvZ2dsZUlucHV0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuaW5wdXQudG9nZ2xlQ2xhc3MoXFxcImlycy1oaWRkZW4taW5wdXRcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNfdGFiX2luZGV4KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LnByb3AoXFxcInRhYmluZGV4XFxcIiwgLTEpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LnJlbW92ZVByb3AoXFxcInRhYmluZGV4XFxcIik7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuaGFzX3RhYl9pbmRleCA9ICF0aGlzLmhhc190YWJfaW5kZXg7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBDb252ZXJ0IHJlYWwgdmFsdWUgdG8gcGVyY2VudFxcbiAgICAgICAgICpcXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfSBYIGluIHJlYWxcXG4gICAgICAgICAqIEBwYXJhbSBub19taW4ge2Jvb2xlYW49fSBkb24ndCB1c2UgbWluIHZhbHVlXFxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBYIGluIHBlcmNlbnRcXG4gICAgICAgICAqL1xcbiAgICAgICAgY29udmVydFRvUGVyY2VudDogZnVuY3Rpb24gKHZhbHVlLCBub19taW4pIHtcXG4gICAgICAgICAgICB2YXIgZGlhcGFzb24gPSB0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5vcHRpb25zLm1pbixcXG4gICAgICAgICAgICAgICAgb25lX3BlcmNlbnQgPSBkaWFwYXNvbiAvIDEwMCxcXG4gICAgICAgICAgICAgICAgdmFsLCBwZXJjZW50O1xcblxcbiAgICAgICAgICAgIGlmICghZGlhcGFzb24pIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5ub19kaWFwYXNvbiA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAobm9fbWluKSB7XFxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlIC0gdGhpcy5vcHRpb25zLm1pbjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcGVyY2VudCA9IHZhbCAvIG9uZV9wZXJjZW50O1xcblxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRml4ZWQocGVyY2VudCk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBDb252ZXJ0IHBlcmNlbnQgdG8gcmVhbCB2YWx1ZXNcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gcGVyY2VudCB7TnVtYmVyfSBYIGluIHBlcmNlbnRcXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFggaW4gcmVhbFxcbiAgICAgICAgICovXFxuICAgICAgICBjb252ZXJ0VG9WYWx1ZTogZnVuY3Rpb24gKHBlcmNlbnQpIHtcXG4gICAgICAgICAgICB2YXIgbWluID0gdGhpcy5vcHRpb25zLm1pbixcXG4gICAgICAgICAgICAgICAgbWF4ID0gdGhpcy5vcHRpb25zLm1heCxcXG4gICAgICAgICAgICAgICAgbWluX2RlY2ltYWxzID0gbWluLnRvU3RyaW5nKCkuc3BsaXQoXFxcIi5cXFwiKVsxXSxcXG4gICAgICAgICAgICAgICAgbWF4X2RlY2ltYWxzID0gbWF4LnRvU3RyaW5nKCkuc3BsaXQoXFxcIi5cXFwiKVsxXSxcXG4gICAgICAgICAgICAgICAgbWluX2xlbmd0aCwgbWF4X2xlbmd0aCxcXG4gICAgICAgICAgICAgICAgYXZnX2RlY2ltYWxzID0gMCxcXG4gICAgICAgICAgICAgICAgYWJzID0gMDtcXG5cXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1pbjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDEwMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1heDtcXG4gICAgICAgICAgICB9XFxuXFxuXFxuICAgICAgICAgICAgaWYgKG1pbl9kZWNpbWFscykge1xcbiAgICAgICAgICAgICAgICBtaW5fbGVuZ3RoID0gbWluX2RlY2ltYWxzLmxlbmd0aDtcXG4gICAgICAgICAgICAgICAgYXZnX2RlY2ltYWxzID0gbWluX2xlbmd0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG1heF9kZWNpbWFscykge1xcbiAgICAgICAgICAgICAgICBtYXhfbGVuZ3RoID0gbWF4X2RlY2ltYWxzLmxlbmd0aDtcXG4gICAgICAgICAgICAgICAgYXZnX2RlY2ltYWxzID0gbWF4X2xlbmd0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG1pbl9sZW5ndGggJiYgbWF4X2xlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBhdmdfZGVjaW1hbHMgPSAobWluX2xlbmd0aCA+PSBtYXhfbGVuZ3RoKSA/IG1pbl9sZW5ndGggOiBtYXhfbGVuZ3RoO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAobWluIDwgMCkge1xcbiAgICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicyhtaW4pO1xcbiAgICAgICAgICAgICAgICBtaW4gPSArKG1pbiArIGFicykudG9GaXhlZChhdmdfZGVjaW1hbHMpO1xcbiAgICAgICAgICAgICAgICBtYXggPSArKG1heCArIGFicykudG9GaXhlZChhdmdfZGVjaW1hbHMpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gKChtYXggLSBtaW4pIC8gMTAwICogcGVyY2VudCkgKyBtaW4sXFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHRoaXMub3B0aW9ucy5zdGVwLnRvU3RyaW5nKCkuc3BsaXQoXFxcIi5cXFwiKVsxXSxcXG4gICAgICAgICAgICAgICAgcmVzdWx0O1xcblxcbiAgICAgICAgICAgIGlmIChzdHJpbmcpIHtcXG4gICAgICAgICAgICAgICAgbnVtYmVyID0gK251bWJlci50b0ZpeGVkKHN0cmluZy5sZW5ndGgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIG51bWJlciA9IG51bWJlciAvIHRoaXMub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICAgICAgICBudW1iZXIgPSBudW1iZXIgKiB0aGlzLm9wdGlvbnMuc3RlcDtcXG5cXG4gICAgICAgICAgICAgICAgbnVtYmVyID0gK251bWJlci50b0ZpeGVkKDApO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoYWJzKSB7XFxuICAgICAgICAgICAgICAgIG51bWJlciAtPSBhYnM7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzdHJpbmcpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gK251bWJlci50b0ZpeGVkKHN0cmluZy5sZW5ndGgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudG9GaXhlZChudW1iZXIpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAocmVzdWx0IDwgdGhpcy5vcHRpb25zLm1pbikge1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm9wdGlvbnMubWluO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID4gdGhpcy5vcHRpb25zLm1heCkge1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm9wdGlvbnMubWF4O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogUm91bmQgcGVyY2VudCB2YWx1ZSB3aXRoIHN0ZXBcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcGFyYW0gcGVyY2VudCB7TnVtYmVyfVxcbiAgICAgICAgICogQHJldHVybnMgcGVyY2VudCB7TnVtYmVyfSByb3VuZGVkXFxuICAgICAgICAgKi9cXG4gICAgICAgIGNhbGNXaXRoU3RlcDogZnVuY3Rpb24gKHBlcmNlbnQpIHtcXG4gICAgICAgICAgICB2YXIgcm91bmRlZCA9IE1hdGgucm91bmQocGVyY2VudCAvIHRoaXMuY29vcmRzLnBfc3RlcCkgKiB0aGlzLmNvb3Jkcy5wX3N0ZXA7XFxuXFxuICAgICAgICAgICAgaWYgKHJvdW5kZWQgPiAxMDApIHtcXG4gICAgICAgICAgICAgICAgcm91bmRlZCA9IDEwMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDEwMCkge1xcbiAgICAgICAgICAgICAgICByb3VuZGVkID0gMTAwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0ZpeGVkKHJvdW5kZWQpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGNoZWNrTWluSW50ZXJ2YWw6IGZ1bmN0aW9uIChwX2N1cnJlbnQsIHBfbmV4dCwgdHlwZSkge1xcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxcbiAgICAgICAgICAgICAgICBuZXh0O1xcblxcbiAgICAgICAgICAgIGlmICghby5taW5faW50ZXJ2YWwpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfY3VycmVudDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuY29udmVydFRvVmFsdWUocF9jdXJyZW50KTtcXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5jb252ZXJ0VG9WYWx1ZShwX25leHQpO1xcblxcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwiZnJvbVxcXCIpIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgLSBjdXJyZW50IDwgby5taW5faW50ZXJ2YWwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0IC0gby5taW5faW50ZXJ2YWw7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAtIG5leHQgPCBvLm1pbl9pbnRlcnZhbCkge1xcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQgKyBvLm1pbl9pbnRlcnZhbDtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VG9QZXJjZW50KGN1cnJlbnQpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGNoZWNrTWF4SW50ZXJ2YWw6IGZ1bmN0aW9uIChwX2N1cnJlbnQsIHBfbmV4dCwgdHlwZSkge1xcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxcbiAgICAgICAgICAgICAgICBuZXh0O1xcblxcbiAgICAgICAgICAgIGlmICghby5tYXhfaW50ZXJ2YWwpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfY3VycmVudDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuY29udmVydFRvVmFsdWUocF9jdXJyZW50KTtcXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5jb252ZXJ0VG9WYWx1ZShwX25leHQpO1xcblxcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwiZnJvbVxcXCIpIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgLSBjdXJyZW50ID4gby5tYXhfaW50ZXJ2YWwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0IC0gby5tYXhfaW50ZXJ2YWw7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAtIG5leHQgPiBvLm1heF9pbnRlcnZhbCkge1xcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQgKyBvLm1heF9pbnRlcnZhbDtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VG9QZXJjZW50KGN1cnJlbnQpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGNoZWNrRGlhcGFzb246IGZ1bmN0aW9uIChwX251bSwgbWluLCBtYXgpIHtcXG4gICAgICAgICAgICB2YXIgbnVtID0gdGhpcy5jb252ZXJ0VG9WYWx1ZShwX251bSksXFxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnM7XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICAgICAgICAgIG1pbiA9IG8ubWluO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1heCAhPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgICAgICAgICAgbWF4ID0gby5tYXg7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChudW0gPCBtaW4pIHtcXG4gICAgICAgICAgICAgICAgbnVtID0gbWluO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAobnVtID4gbWF4KSB7XFxuICAgICAgICAgICAgICAgIG51bSA9IG1heDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRvUGVyY2VudChudW0pO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIHRvRml4ZWQ6IGZ1bmN0aW9uIChudW0pIHtcXG4gICAgICAgICAgICBudW0gPSBudW0udG9GaXhlZCgyMCk7XFxuICAgICAgICAgICAgcmV0dXJuICtudW07XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgX3ByZXR0aWZ5OiBmdW5jdGlvbiAobnVtKSB7XFxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucHJldHRpZnlfZW5hYmxlZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXR0aWZ5ICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMucHJldHRpZnkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wcmV0dGlmeShudW0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXR0aWZ5KG51bSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIHByZXR0aWZ5OiBmdW5jdGlvbiAobnVtKSB7XFxuICAgICAgICAgICAgdmFyIG4gPSBudW0udG9TdHJpbmcoKTtcXG4gICAgICAgICAgICByZXR1cm4gbi5yZXBsYWNlKC8oXFxcXGR7MSwzfSg/PSg/OlxcXFxkXFxcXGRcXFxcZCkrKD8hXFxcXGQpKSkvZywgXFxcIiQxXFxcIiArIHRoaXMub3B0aW9ucy5wcmV0dGlmeV9zZXBhcmF0b3IpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGNoZWNrRWRnZXM6IGZ1bmN0aW9uIChsZWZ0LCB3aWR0aCkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZvcmNlX2VkZ2VzKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRml4ZWQobGVmdCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgMCkge1xcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPiAxMDAgLSB3aWR0aCkge1xcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMTAwIC0gd2lkdGg7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRml4ZWQobGVmdCk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgICAgICAgciA9IHRoaXMucmVzdWx0LFxcbiAgICAgICAgICAgICAgICB2ID0gby52YWx1ZXMsXFxuICAgICAgICAgICAgICAgIHZsID0gdi5sZW5ndGgsXFxuICAgICAgICAgICAgICAgIHZhbHVlLFxcbiAgICAgICAgICAgICAgICBpO1xcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby5taW4gPT09IFxcXCJzdHJpbmdcXFwiKSBvLm1pbiA9ICtvLm1pbjtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIG8ubWF4ID09PSBcXFwic3RyaW5nXFxcIikgby5tYXggPSArby5tYXg7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvLmZyb20gPT09IFxcXCJzdHJpbmdcXFwiKSBvLmZyb20gPSArby5mcm9tO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby50byA9PT0gXFxcInN0cmluZ1xcXCIpIG8udG8gPSArby50bztcXG4gICAgICAgICAgICBpZiAodHlwZW9mIG8uc3RlcCA9PT0gXFxcInN0cmluZ1xcXCIpIG8uc3RlcCA9ICtvLnN0ZXA7XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvLmZyb21fbWluID09PSBcXFwic3RyaW5nXFxcIikgby5mcm9tX21pbiA9ICtvLmZyb21fbWluO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby5mcm9tX21heCA9PT0gXFxcInN0cmluZ1xcXCIpIG8uZnJvbV9tYXggPSArby5mcm9tX21heDtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIG8udG9fbWluID09PSBcXFwic3RyaW5nXFxcIikgby50b19taW4gPSArby50b19taW47XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvLnRvX21heCA9PT0gXFxcInN0cmluZ1xcXCIpIG8udG9fbWF4ID0gK28udG9fbWF4O1xcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby5ncmlkX251bSA9PT0gXFxcInN0cmluZ1xcXCIpIG8uZ3JpZF9udW0gPSArby5ncmlkX251bTtcXG5cXG4gICAgICAgICAgICBpZiAoby5tYXggPCBvLm1pbikge1xcbiAgICAgICAgICAgICAgICBvLm1heCA9IG8ubWluO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodmwpIHtcXG4gICAgICAgICAgICAgICAgby5wX3ZhbHVlcyA9IFtdO1xcbiAgICAgICAgICAgICAgICBvLm1pbiA9IDA7XFxuICAgICAgICAgICAgICAgIG8ubWF4ID0gdmwgLSAxO1xcbiAgICAgICAgICAgICAgICBvLnN0ZXAgPSAxO1xcbiAgICAgICAgICAgICAgICBvLmdyaWRfbnVtID0gby5tYXg7XFxuICAgICAgICAgICAgICAgIG8uZ3JpZF9zbmFwID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZsOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZbaV07XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbaV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ByZXR0aWZ5KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2W2ldO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgby5wX3ZhbHVlcy5wdXNoKHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodHlwZW9mIG8uZnJvbSAhPT0gXFxcIm51bWJlclxcXCIgfHwgaXNOYU4oby5mcm9tKSkge1xcbiAgICAgICAgICAgICAgICBvLmZyb20gPSBvLm1pbjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvLnRvICE9PSBcXFwibnVtYmVyXFxcIiB8fCBpc05hTihvLnRvKSkge1xcbiAgICAgICAgICAgICAgICBvLnRvID0gby5tYXg7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChvLnR5cGUgPT09IFxcXCJzaW5nbGVcXFwiKSB7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChvLmZyb20gPCBvLm1pbikgby5mcm9tID0gby5taW47XFxuICAgICAgICAgICAgICAgIGlmIChvLmZyb20gPiBvLm1heCkgby5mcm9tID0gby5tYXg7XFxuXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG8uZnJvbSA8IG8ubWluKSBvLmZyb20gPSBvLm1pbjtcXG4gICAgICAgICAgICAgICAgaWYgKG8uZnJvbSA+IG8ubWF4KSBvLmZyb20gPSBvLm1heDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG8udG8gPCBvLm1pbikgby50byA9IG8ubWluO1xcbiAgICAgICAgICAgICAgICBpZiAoby50byA+IG8ubWF4KSBvLnRvID0gby5tYXg7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZV9jaGVjay5mcm9tKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51cGRhdGVfY2hlY2suZnJvbSAhPT0gby5mcm9tKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uZnJvbSA+IG8udG8pIG8uZnJvbSA9IG8udG87XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51cGRhdGVfY2hlY2sudG8gIT09IG8udG8pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby50byA8IG8uZnJvbSkgby50byA9IG8uZnJvbTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoby5mcm9tID4gby50bykgby5mcm9tID0gby50bztcXG4gICAgICAgICAgICAgICAgaWYgKG8udG8gPCBvLmZyb20pIG8udG8gPSBvLmZyb207XFxuXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby5zdGVwICE9PSBcXFwibnVtYmVyXFxcIiB8fCBpc05hTihvLnN0ZXApIHx8ICFvLnN0ZXAgfHwgby5zdGVwIDwgMCkge1xcbiAgICAgICAgICAgICAgICBvLnN0ZXAgPSAxO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodHlwZW9mIG8uZnJvbV9taW4gPT09IFxcXCJudW1iZXJcXFwiICYmIG8uZnJvbSA8IG8uZnJvbV9taW4pIHtcXG4gICAgICAgICAgICAgICAgby5mcm9tID0gby5mcm9tX21pbjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvLmZyb21fbWF4ID09PSBcXFwibnVtYmVyXFxcIiAmJiBvLmZyb20gPiBvLmZyb21fbWF4KSB7XFxuICAgICAgICAgICAgICAgIG8uZnJvbSA9IG8uZnJvbV9tYXg7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby50b19taW4gPT09IFxcXCJudW1iZXJcXFwiICYmIG8udG8gPCBvLnRvX21pbikge1xcbiAgICAgICAgICAgICAgICBvLnRvID0gby50b19taW47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby50b19tYXggPT09IFxcXCJudW1iZXJcXFwiICYmIG8uZnJvbSA+IG8udG9fbWF4KSB7XFxuICAgICAgICAgICAgICAgIG8udG8gPSBvLnRvX21heDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHIubWluICE9PSBvLm1pbikge1xcbiAgICAgICAgICAgICAgICAgICAgci5taW4gPSBvLm1pbjtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoci5tYXggIT09IG8ubWF4KSB7XFxuICAgICAgICAgICAgICAgICAgICByLm1heCA9IG8ubWF4O1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChyLmZyb20gPCByLm1pbiB8fCByLmZyb20gPiByLm1heCkge1xcbiAgICAgICAgICAgICAgICAgICAgci5mcm9tID0gby5mcm9tO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChyLnRvIDwgci5taW4gfHwgci50byA+IHIubWF4KSB7XFxuICAgICAgICAgICAgICAgICAgICByLnRvID0gby50bztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodHlwZW9mIG8ubWluX2ludGVydmFsICE9PSBcXFwibnVtYmVyXFxcIiB8fCBpc05hTihvLm1pbl9pbnRlcnZhbCkgfHwgIW8ubWluX2ludGVydmFsIHx8IG8ubWluX2ludGVydmFsIDwgMCkge1xcbiAgICAgICAgICAgICAgICBvLm1pbl9pbnRlcnZhbCA9IDA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby5tYXhfaW50ZXJ2YWwgIT09IFxcXCJudW1iZXJcXFwiIHx8IGlzTmFOKG8ubWF4X2ludGVydmFsKSB8fCAhby5tYXhfaW50ZXJ2YWwgfHwgby5tYXhfaW50ZXJ2YWwgPCAwKSB7XFxuICAgICAgICAgICAgICAgIG8ubWF4X2ludGVydmFsID0gMDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKG8ubWluX2ludGVydmFsICYmIG8ubWluX2ludGVydmFsID4gby5tYXggLSBvLm1pbikge1xcbiAgICAgICAgICAgICAgICBvLm1pbl9pbnRlcnZhbCA9IG8ubWF4IC0gby5taW47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChvLm1heF9pbnRlcnZhbCAmJiBvLm1heF9pbnRlcnZhbCA+IG8ubWF4IC0gby5taW4pIHtcXG4gICAgICAgICAgICAgICAgby5tYXhfaW50ZXJ2YWwgPSBvLm1heCAtIG8ubWluO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICBkZWNvcmF0ZTogZnVuY3Rpb24gKG51bSwgb3JpZ2luYWwpIHtcXG4gICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnM7XFxuXFxuICAgICAgICAgICAgaWYgKG8ucHJlZml4KSB7XFxuICAgICAgICAgICAgICAgIGRlY29yYXRlZCArPSBvLnByZWZpeDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZGVjb3JhdGVkICs9IG51bTtcXG5cXG4gICAgICAgICAgICBpZiAoby5tYXhfcG9zdGZpeCkge1xcbiAgICAgICAgICAgICAgICBpZiAoby52YWx1ZXMubGVuZ3RoICYmIG51bSA9PT0gby5wX3ZhbHVlc1tvLm1heF0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRlZCArPSBvLm1heF9wb3N0Zml4O1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ucG9zdGZpeCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlZCArPSBcXFwiIFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWwgPT09IG8ubWF4KSB7XFxuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZWQgKz0gby5tYXhfcG9zdGZpeDtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnBvc3RmaXgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZWQgKz0gXFxcIiBcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChvLnBvc3RmaXgpIHtcXG4gICAgICAgICAgICAgICAgZGVjb3JhdGVkICs9IG8ucG9zdGZpeDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRlZDtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICB1cGRhdGVGcm9tOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdGhpcy5yZXN1bHQuZnJvbSA9IHRoaXMub3B0aW9ucy5mcm9tO1xcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb21fcGVyY2VudCA9IHRoaXMuY29udmVydFRvUGVyY2VudCh0aGlzLnJlc3VsdC5mcm9tKTtcXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5mcm9tX3ByZXR0eSA9IHRoaXMuX3ByZXR0aWZ5KHRoaXMucmVzdWx0LmZyb20pO1xcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWVzKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmZyb21fdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWVzW3RoaXMucmVzdWx0LmZyb21dO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICB1cGRhdGVUbzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnRvID0gdGhpcy5vcHRpb25zLnRvO1xcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnRvX3BlcmNlbnQgPSB0aGlzLmNvbnZlcnRUb1BlcmNlbnQodGhpcy5yZXN1bHQudG8pO1xcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnRvX3ByZXR0eSA9IHRoaXMuX3ByZXR0aWZ5KHRoaXMucmVzdWx0LnRvKTtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlcykge1xcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b192YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZXNbdGhpcy5yZXN1bHQudG9dO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICB1cGRhdGVSZXN1bHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5taW4gPSB0aGlzLm9wdGlvbnMubWluO1xcbiAgICAgICAgICAgIHRoaXMucmVzdWx0Lm1heCA9IHRoaXMub3B0aW9ucy5tYXg7XFxuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tKCk7XFxuICAgICAgICAgICAgdGhpcy51cGRhdGVUbygpO1xcbiAgICAgICAgfSxcXG5cXG5cXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICAgIC8vIEdyaWRcXG5cXG4gICAgICAgIGFwcGVuZEdyaWQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5ncmlkKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgICAgIGksIHosXFxuXFxuICAgICAgICAgICAgICAgIHRvdGFsID0gby5tYXggLSBvLm1pbixcXG4gICAgICAgICAgICAgICAgYmlnX251bSA9IG8uZ3JpZF9udW0sXFxuICAgICAgICAgICAgICAgIGJpZ19wID0gMCxcXG4gICAgICAgICAgICAgICAgYmlnX3cgPSAwLFxcblxcbiAgICAgICAgICAgICAgICBzbWFsbF9tYXggPSA0LFxcbiAgICAgICAgICAgICAgICBsb2NhbF9zbWFsbF9tYXgsXFxuICAgICAgICAgICAgICAgIHNtYWxsX3AsXFxuICAgICAgICAgICAgICAgIHNtYWxsX3cgPSAwLFxcblxcbiAgICAgICAgICAgICAgICByZXN1bHQsXFxuICAgICAgICAgICAgICAgIGh0bWwgPSAnJztcXG5cXG5cXG5cXG4gICAgICAgICAgICB0aGlzLmNhbGNHcmlkTWFyZ2luKCk7XFxuXFxuICAgICAgICAgICAgaWYgKG8uZ3JpZF9zbmFwKSB7XFxuICAgICAgICAgICAgICAgIGJpZ19udW0gPSB0b3RhbCAvIG8uc3RlcDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGJpZ19udW0gPiA1MCkgYmlnX251bSA9IDUwO1xcbiAgICAgICAgICAgIGJpZ19wID0gdGhpcy50b0ZpeGVkKDEwMCAvIGJpZ19udW0pO1xcblxcbiAgICAgICAgICAgIGlmIChiaWdfbnVtID4gNCkge1xcbiAgICAgICAgICAgICAgICBzbWFsbF9tYXggPSAzO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYmlnX251bSA+IDcpIHtcXG4gICAgICAgICAgICAgICAgc21hbGxfbWF4ID0gMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJpZ19udW0gPiAxNCkge1xcbiAgICAgICAgICAgICAgICBzbWFsbF9tYXggPSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYmlnX251bSA+IDI4KSB7XFxuICAgICAgICAgICAgICAgIHNtYWxsX21heCA9IDA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiaWdfbnVtICsgMTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxvY2FsX3NtYWxsX21heCA9IHNtYWxsX21heDtcXG5cXG4gICAgICAgICAgICAgICAgYmlnX3cgPSB0aGlzLnRvRml4ZWQoYmlnX3AgKiBpKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGJpZ193ID4gMTAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBiaWdfdyA9IDEwMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5iaWdbaV0gPSBiaWdfdztcXG5cXG4gICAgICAgICAgICAgICAgc21hbGxfcCA9IChiaWdfdyAtIChiaWdfcCAqIChpIC0gMSkpKSAvIChsb2NhbF9zbWFsbF9tYXggKyAxKTtcXG5cXG4gICAgICAgICAgICAgICAgZm9yICh6ID0gMTsgeiA8PSBsb2NhbF9zbWFsbF9tYXg7IHorKykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpZ193ID09PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBzbWFsbF93ID0gdGhpcy50b0ZpeGVkKGJpZ193IC0gKHNtYWxsX3AgKiB6KSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cXFwiaXJzLWdyaWQtcG9sIHNtYWxsXFxcIiBzdHlsZT1cXFwibGVmdDogJyArIHNtYWxsX3cgKyAnJVxcXCI+PC9zcGFuPic7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XFxcImlycy1ncmlkLXBvbFxcXCIgc3R5bGU9XFxcImxlZnQ6ICcgKyBiaWdfdyArICclXFxcIj48L3NwYW4+JztcXG5cXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb252ZXJ0VG9WYWx1ZShiaWdfdyk7XFxuICAgICAgICAgICAgICAgIGlmIChvLnZhbHVlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG8ucF92YWx1ZXNbcmVzdWx0XTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ByZXR0aWZ5KHJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XFxcImlycy1ncmlkLXRleHQganMtZ3JpZC10ZXh0LScgKyBpICsgJ1xcXCIgc3R5bGU9XFxcImxlZnQ6ICcgKyBiaWdfdyArICclXFxcIj4nICsgcmVzdWx0ICsgJzwvc3Bhbj4nO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmNvb3Jkcy5iaWdfbnVtID0gTWF0aC5jZWlsKGJpZ19udW0gKyAxKTtcXG5cXG5cXG5cXG4gICAgICAgICAgICB0aGlzLiRjYWNoZS5jb250LmFkZENsYXNzKFxcXCJpcnMtd2l0aC1ncmlkXFxcIik7XFxuICAgICAgICAgICAgdGhpcy4kY2FjaGUuZ3JpZC5odG1sKGh0bWwpO1xcbiAgICAgICAgICAgIHRoaXMuY2FjaGVHcmlkTGFiZWxzKCk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgY2FjaGVHcmlkTGFiZWxzOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyICRsYWJlbCwgaSxcXG4gICAgICAgICAgICAgICAgbnVtID0gdGhpcy5jb29yZHMuYmlnX251bTtcXG5cXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgJGxhYmVsID0gdGhpcy4kY2FjaGUuZ3JpZC5maW5kKFxcXCIuanMtZ3JpZC10ZXh0LVxcXCIgKyBpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kY2FjaGUuZ3JpZF9sYWJlbHMucHVzaCgkbGFiZWwpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLmNhbGNHcmlkTGFiZWxzKCk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgY2FsY0dyaWRMYWJlbHM6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgaSwgbGFiZWwsIHN0YXJ0ID0gW10sIGZpbmlzaCA9IFtdLFxcbiAgICAgICAgICAgICAgICBudW0gPSB0aGlzLmNvb3Jkcy5iaWdfbnVtO1xcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW07IGkrKykge1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5iaWdfd1tpXSA9IHRoaXMuJGNhY2hlLmdyaWRfbGFiZWxzW2ldLm91dGVyV2lkdGgoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5iaWdfcFtpXSA9IHRoaXMudG9GaXhlZCh0aGlzLmNvb3Jkcy5iaWdfd1tpXSAvIHRoaXMuY29vcmRzLndfcnMgKiAxMDApO1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5iaWdfeFtpXSA9IHRoaXMudG9GaXhlZCh0aGlzLmNvb3Jkcy5iaWdfcFtpXSAvIDIpO1xcblxcbiAgICAgICAgICAgICAgICBzdGFydFtpXSA9IHRoaXMudG9GaXhlZCh0aGlzLmNvb3Jkcy5iaWdbaV0gLSB0aGlzLmNvb3Jkcy5iaWdfeFtpXSk7XFxuICAgICAgICAgICAgICAgIGZpbmlzaFtpXSA9IHRoaXMudG9GaXhlZChzdGFydFtpXSArIHRoaXMuY29vcmRzLmJpZ19wW2ldKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZV9lZGdlcykge1xcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRbMF0gPCAtdGhpcy5jb29yZHMuZ3JpZF9nYXApIHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WzBdID0gLXRoaXMuY29vcmRzLmdyaWRfZ2FwO1xcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoWzBdID0gdGhpcy50b0ZpeGVkKHN0YXJ0WzBdICsgdGhpcy5jb29yZHMuYmlnX3BbMF0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMuYmlnX3hbMF0gPSB0aGlzLmNvb3Jkcy5ncmlkX2dhcDtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoW251bSAtIDFdID4gMTAwICsgdGhpcy5jb29yZHMuZ3JpZF9nYXApIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFtudW0gLSAxXSA9IDEwMCArIHRoaXMuY29vcmRzLmdyaWRfZ2FwO1xcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRbbnVtIC0gMV0gPSB0aGlzLnRvRml4ZWQoZmluaXNoW251bSAtIDFdIC0gdGhpcy5jb29yZHMuYmlnX3BbbnVtIC0gMV0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHMuYmlnX3hbbnVtIC0gMV0gPSB0aGlzLnRvRml4ZWQodGhpcy5jb29yZHMuYmlnX3BbbnVtIC0gMV0gLSB0aGlzLmNvb3Jkcy5ncmlkX2dhcCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5jYWxjR3JpZENvbGxpc2lvbigyLCBzdGFydCwgZmluaXNoKTtcXG4gICAgICAgICAgICB0aGlzLmNhbGNHcmlkQ29sbGlzaW9uKDQsIHN0YXJ0LCBmaW5pc2gpO1xcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW07IGkrKykge1xcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuJGNhY2hlLmdyaWRfbGFiZWxzW2ldWzBdO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb29yZHMuYmlnX3hbaV0gIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9IC10aGlzLmNvb3Jkcy5iaWdfeFtpXSArIFxcXCIlXFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvLyBDb2xsaXNpb25zIENhbGMgQmV0YVxcbiAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdGhlbiBoYXZlIHBsZW50eSBvZiB0aW1lXFxuICAgICAgICBjYWxjR3JpZENvbGxpc2lvbjogZnVuY3Rpb24gKHN0ZXAsIHN0YXJ0LCBmaW5pc2gpIHtcXG4gICAgICAgICAgICB2YXIgaSwgbmV4dF9pLCBsYWJlbCxcXG4gICAgICAgICAgICAgICAgbnVtID0gdGhpcy5jb29yZHMuYmlnX251bTtcXG5cXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtOyBpICs9IHN0ZXApIHtcXG4gICAgICAgICAgICAgICAgbmV4dF9pID0gaSArIChzdGVwIC8gMik7XFxuICAgICAgICAgICAgICAgIGlmIChuZXh0X2kgPj0gbnVtKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuJGNhY2hlLmdyaWRfbGFiZWxzW25leHRfaV1bMF07XFxuXFxuICAgICAgICAgICAgICAgIGlmIChmaW5pc2hbaV0gPD0gc3RhcnRbbmV4dF9pXSkge1xcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJ2aXNpYmxlXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICBjYWxjR3JpZE1hcmdpbjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmdyaWRfbWFyZ2luKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5jb29yZHMud19ycyA9IHRoaXMuJGNhY2hlLnJzLm91dGVyV2lkdGgoZmFsc2UpO1xcbiAgICAgICAgICAgIGlmICghdGhpcy5jb29yZHMud19ycykge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gXFxcInNpbmdsZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMud19oYW5kbGUgPSB0aGlzLiRjYWNoZS5zX3NpbmdsZS5vdXRlcldpZHRoKGZhbHNlKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy53X2hhbmRsZSA9IHRoaXMuJGNhY2hlLnNfZnJvbS5vdXRlcldpZHRoKGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5jb29yZHMucF9oYW5kbGUgPSB0aGlzLnRvRml4ZWQodGhpcy5jb29yZHMud19oYW5kbGUgIC8gdGhpcy5jb29yZHMud19ycyAqIDEwMCk7XFxuICAgICAgICAgICAgdGhpcy5jb29yZHMuZ3JpZF9nYXAgPSB0aGlzLnRvRml4ZWQoKHRoaXMuY29vcmRzLnBfaGFuZGxlIC8gMikgLSAwLjEpO1xcblxcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmdyaWRbMF0uc3R5bGUud2lkdGggPSB0aGlzLnRvRml4ZWQoMTAwIC0gdGhpcy5jb29yZHMucF9oYW5kbGUpICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmdyaWRbMF0uc3R5bGUubGVmdCA9IHRoaXMuY29vcmRzLmdyaWRfZ2FwICsgXFxcIiVcXFwiO1xcbiAgICAgICAgfSxcXG5cXG5cXG5cXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICAgIC8vIFB1YmxpYyBtZXRob2RzXFxuXFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5pc191cGRhdGUgPSB0cnVlO1xcblxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mcm9tID0gdGhpcy5yZXN1bHQuZnJvbTtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG8gPSB0aGlzLnJlc3VsdC50bztcXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV9jaGVjay5mcm9tID0gdGhpcy5yZXN1bHQuZnJvbTtcXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV9jaGVjay50byA9IHRoaXMucmVzdWx0LnRvO1xcblxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XFxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KG9wdGlvbnMpO1xcblxcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSW5wdXQoKTtcXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIHRoaXMuaW5pdCh0cnVlKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XFxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy50b2dnbGVJbnB1dCgpO1xcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLmlucHV0LnByb3AoXFxcInJlYWRvbmx5XFxcIiwgZmFsc2UpO1xcbiAgICAgICAgICAgICQuZGF0YSh0aGlzLmlucHV0LCBcXFwiaW9uUmFuZ2VTbGlkZXJcXFwiLCBudWxsKTtcXG5cXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgICQuZm4uaW9uUmFuZ2VTbGlkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICBpZiAoISQuZGF0YSh0aGlzLCBcXFwiaW9uUmFuZ2VTbGlkZXJcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAkLmRhdGEodGhpcywgXFxcImlvblJhbmdlU2xpZGVyXFxcIiwgbmV3IElvblJhbmdlU2xpZGVyKHRoaXMsIG9wdGlvbnMsIHBsdWdpbl9jb3VudCsrKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuXFxuXFxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIC8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXFxuICAgIC8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcXG5cXG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci4gZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxcblxcbiAgICAvLyBNSVQgbGljZW5zZVxcblxcbiAgICAoZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgbGFzdFRpbWUgPSAwO1xcbiAgICAgICAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xcbiAgICAgICAgZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0rJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdKydDYW5jZWxBbmltYXRpb25GcmFtZSddXFxuICAgICAgICAgICAgICAgIHx8IHdpbmRvd1t2ZW5kb3JzW3hdKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICAgICAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTsgfSxcXG4gICAgICAgICAgICAgICAgICAgIHRpbWVUb0NhbGwpO1xcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSlcXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xcbiAgICAgICAgICAgIH07XFxuICAgIH0oKSk7XFxuXFxufSkpO1xcblwiIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cbiIsInJlcXVpcmUoXCIhIUU6XFxcXFNpdGVzXFxcXG1lLW1lc3NpYS1sb2NhbC5jb21cXFxcd3AtY29udGVudFxcXFx0aGVtZXNcXFxcbWVzc2lhXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFFOlxcXFxTaXRlc1xcXFxtZS1tZXNzaWEtbG9jYWwuY29tXFxcXHdwLWNvbnRlbnRcXFxcdGhlbWVzXFxcXG1lc3NpYVxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFFOlxcXFxTaXRlc1xcXFxtZS1tZXNzaWEtbG9jYWwuY29tXFxcXHdwLWNvbnRlbnRcXFxcdGhlbWVzXFxcXG1lc3NpYVxcXFxub2RlX21vZHVsZXNcXFxcaW9uLXJhbmdlc2xpZGVyXFxcXGpzXFxcXGlvbi5yYW5nZVNsaWRlci5qc1wiKSkiLCJpbXBvcnQgJ25vZGVNb2R1bGVzL2lvbi1yYW5nZXNsaWRlci9qcy9pb24ucmFuZ2VTbGlkZXIuanMnOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBTdHlsZVxuaW1wb3J0IFwiLi4vbGVzcy9fY29tcG9uZW50cy9fcmFuZ2UubGVzc1wiO1xuXG4vLyBTY3JpcHRzXG5pbXBvcnQgXCIuLi9qcy9fY29tcG9uZW50cy9fcmFuZ2UuanNcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=